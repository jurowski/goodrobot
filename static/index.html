<!DOCTYPE html>
<html>
<head>
    <title>Voice AI Assistant</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/static/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon/favicon-16x16.png">
    <link rel="manifest" href="/static/favicon/site.webmanifest">
    <style>
        :root {
            --bg-primary: #1a1b1e;
            --bg-secondary: #2c2e33;
            --text-primary: #e4e6eb;
            --text-secondary: #b0b3b8;
            --accent: #4f46e5;
            --accent-hover: #6366f1;
            --shadow: rgba(0, 0, 0, 0.2);
            --success: #22c55e;
            --error: #ef4444;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Update logo container layout */
        .logo-container {
            text-align: center;
            margin-bottom: 40px;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 30px;
            align-items: start;
            max-width: 1200px;
            margin: 0 auto 40px;
            padding: 20px;
        }

        .logo-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .response-section {
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-height: 200px;
            width: 100%;
        }

        /* Update response container styles */
        .response-container {
            margin-top: 0;
            padding: 20px;
            background: rgba(79, 70, 229, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(79, 70, 229, 0.2);
            flex: 1;
            transition: all 0.3s ease;
            /* Remove display property - container should always be visible */
        }

        .response-container.active {
            background: rgba(79, 70, 229, 0.1);
            border-color: var(--accent);
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.1);
        }

        .response-text {
            min-height: 100px;
            margin: 10px 0;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        .response-container.active .response-text {
            color: var(--text-primary);
        }

        .response-label {
            color: var(--text-secondary);
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        .response-container.active .response-label {
            opacity: 1;
        }

        .text-size-control {
            margin-top: 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .logo-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .response-section {
                min-height: 150px;
            }
        }

        .logo {
            width: 200px;
            height: auto;
            filter: drop-shadow(0 0 10px rgba(79, 70, 229, 0.3));
            transition: filter 0.3s ease;
        }

        .logo:hover {
            filter: drop-shadow(0 0 15px rgba(79, 70, 229, 0.5));
        }
        
        h1 {
            color: var(--text-primary);
            text-align: center;
            margin: 0;
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .transcription-container {
            background-color: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            margin: 20px auto;
            max-width: 800px;
            box-shadow: 0 4px 6px var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .transcription-container:hover {
            border-color: var(--accent);
            box-shadow: 0 8px 12px var(--shadow);
        }

        .transcription-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .transcription-text {
            color: var(--text-primary);
            font-size: 1.2rem;
            line-height: 1.5;
            min-height: 24px;
        }

        .transcription-text:empty::before {
            content: "Waiting for transcription...";
            color: var(--text-secondary);
            font-style: italic;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            padding: 20px;
        }
        
        .panel {
            background-color: var(--bg-secondary);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px var(--shadow);
            transition: all 0.3s ease;
            text-decoration: none;
            color: inherit;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 12px var(--shadow);
            border-color: var(--accent);
        }
        
        .panel h2 {
            color: var(--text-primary);
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .panel p {
            color: var(--text-secondary);
            margin: 0 0 20px 0;
            line-height: 1.5;
            font-size: 1rem;
        }
        
        .api-link {
            display: inline-block;
            margin-top: 10px;
            color: var(--accent);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            padding: 8px 12px;
            border-radius: 6px;
            background-color: rgba(79, 70, 229, 0.1);
            transition: all 0.2s ease;
        }
        
        .api-link:hover {
            background-color: rgba(79, 70, 229, 0.2);
            color: var(--accent-hover);
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .grid {
                padding: 10px;
            }
            
            .panel {
                padding: 20px;
            }
        }

        .live-panel {
            grid-column: 1 / -1;
            text-align: center;
            padding: 15px !important;
        }

        .live-panel h2 {
            font-size: 1.2rem;
            margin-bottom: 8px;
        }

        .live-panel p {
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .status-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            margin-right: auto;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
            background-color: var(--text-secondary);
        }

        .control-button {
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        .metrics-container {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin: 10px 0;
            padding: 10px;
        }

        .metric-box {
            padding: 6px;
            font-size: 0.8rem;
        }

        .metric-label {
            font-size: 0.7rem;
            margin-bottom: 2px;
        }

        .metric-value {
            font-size: 1rem;
        }

        .visualizer-container {
            height: 60px;
            margin: 10px 0;
        }

        .voice-settings {
            margin: 10px 0;
            padding: 10px;
        }

        .voice-settings h3 {
            font-size: 1rem;
            margin-bottom: 8px;
        }

        .voice-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .voice-select {
            padding: 6px;
            font-size: 0.9rem;
        }

        .voice-toggle {
            padding: 6px 10px;
            font-size: 0.9rem;
        }

        .voice-provider {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .provider-option {
            padding: 6px;
            font-size: 0.9rem;
        }

        .api-key-input {
            padding: 6px;
            margin-top: 8px;
            font-size: 0.9rem;
        }

        .transcript {
            margin-top: 10px;
            padding: 10px;
            min-height: 60px;
            max-height: 100px;
            font-size: 0.9rem;
        }

        .status-indicator.active {
            background-color: var(--success);
            animation: pulse 2s infinite;
        }
        
        .status-indicator.detected {
            background-color: var(--accent);
        }
        
        .status-indicator.error {
            background-color: var(--error);
        }
        
        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .transcript {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--bg-secondary);
            border-radius: 8px;
            text-align: left;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* Audio metrics styles */
        .metrics-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
            padding: 15px;
            background-color: var(--bg-secondary);
            border-radius: 8px;
        }

        .metric-box {
            padding: 10px;
            border-radius: 6px;
            background-color: rgba(255, 255, 255, 0.05);
            text-align: center;
        }

        .metric-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .volume-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--accent);
            transition: height 0.1s ease;
            position: relative;
        }

        .volume-bar::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 2px;
            height: 100%;
            background-color: var(--accent);
            animation: edgeGlow 2s infinite;
            box-shadow: 0 0 4px var(--accent);
        }

        @keyframes edgeGlow {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }

        .noise-floor {
            position: absolute;
            width: 100%;
            height: 2px;
            background-color: var(--error);
            transition: bottom 0.3s ease;
        }

        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        /* Header styles */
        .header {
            background-color: var(--bg-secondary);
            padding: 1rem;
            margin-bottom: 2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .nav-links {
            display: flex;
            gap: 1.5rem;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .nav-link:hover {
            color: var(--text-primary);
        }

        .nav-link.active {
            color: var(--accent);
        }

        /* Voice output styles */
        .voice-settings {
            margin: 20px 0;
            padding: 15px;
            background-color: var(--bg-secondary);
            border-radius: 8px;
        }

        .voice-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .voice-select {
            flex: 1;
            padding: 8px;
            border-radius: 6px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .voice-select:focus {
            border-color: var(--accent);
            outline: none;
        }

        .voice-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .voice-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .voice-toggle.active {
            background-color: var(--accent);
        }

        .voice-toggle input[type="checkbox"] {
            margin: 0;
        }

        .voice-provider {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .provider-option {
            flex: 1;
            padding: 8px;
            text-align: center;
            border-radius: 6px;
            background-color: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .provider-option:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .provider-option.active {
            background-color: var(--accent);
        }

        .api-key-input {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            border-radius: 6px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .api-key-input:focus {
            border-color: var(--accent);
            outline: none;
        }

        /* Debug log styles */
        .debug-section {
            margin-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 10px;
        }

        .debug-header {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        .debug-header:hover {
            color: var(--text-primary);
        }

        .debug-toggle {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid currentColor;
            transition: transform 0.2s ease;
        }

        .debug-toggle.expanded {
            transform: rotate(-180deg);
        }

        .debug-log {
            display: none;
            font-family: monospace;
            font-size: 11px;
            color: var(--text-secondary);
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .debug-log.expanded {
            display: block;
        }

        .debug-entry {
            margin: 2px 0;
            line-height: 1.4;
        }

        .debug-entry.error {
            color: var(--error);
        }

        .robot-status-bar {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 16px 0 8px 0;
        }
        .robot-status {
            padding: 6px 14px;
            border-radius: 16px;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-weight: 500;
            transition: background 0.2s, color 0.2s;
        }
        .robot-status.active {
            background: var(--accent);
            color: #fff;
            font-weight: 700;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .text-input-container {
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .text-input-wrapper {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }

        .text-input {
            flex: 1;
            padding: 10px;
            border-radius: 6px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            font-family: inherit;
            resize: vertical;
            min-height: 60px;
        }

        .text-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        #sendButton {
            align-self: flex-end;
            height: 40px;
            padding: 0 20px;
        }

        .context-viewer {
            margin-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .context-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 15px 10px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .context-header:hover {
            color: var(--text-primary);
        }

        .context-toggle {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid currentColor;
            transition: transform 0.2s ease;
        }

        .context-toggle.expanded {
            transform: rotate(-180deg);
        }

        .memory-count {
            margin-left: auto;
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .context-content {
            display: none;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .context-content.expanded {
            display: block;
        }

        .memory-filters {
            margin-bottom: 15px;
        }

        .memory-search {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .memory-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        .memory-tag {
            padding: 4px 8px;
            border-radius: 12px;
            background: var(--accent);
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .memory-tag.active {
            opacity: 1;
        }

        .memories-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .memory-item {
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .memory-item:hover {
            border-color: var(--accent);
        }

        .memory-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .memory-tags-list {
            display: flex;
            gap: 4px;
        }

        .memory-tag-small {
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(79, 70, 229, 0.3);
            font-size: 0.7rem;
        }

        .memory-timestamp {
            font-style: italic;
        }

        .memory-content {
            color: var(--text-primary);
            font-size: 0.9rem;
            line-height: 1.4;
        }

        /* Add tooltip styles */
        .tooltip-trigger {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: help;
        }

        .info-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            color: white;
            font-size: 12px;
            line-height: 16px;
            text-align: center;
            margin-left: 6px;
            cursor: help;
        }

        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--accent);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.8rem;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            width: max-content;
            max-width: 300px;
        }

        .tooltip-trigger:hover .tooltip {
            opacity: 1;
        }

        .tooltip-wide {
            white-space: normal;
            text-align: left;
            line-height: 1.4;
        }

        /* Add response display styles */
        .response-container {
            margin-top: 10px;
            padding: 15px;
            background: rgba(79, 70, 229, 0.1);
            border-radius: 8px;
            border: 1px solid var(--accent);
            display: none;
        }

        .response-container.active {
            display: block;
        }

        .response-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .response-text {
            color: var(--text-primary);
            font-size: 1.1rem;
            line-height: 1.5;
        }

        /* Add speaking animation */
        @keyframes speaking-glow {
            0% { filter: drop-shadow(0 0 10px rgba(79, 70, 229, 0.3)); }
            50% { filter: drop-shadow(0 0 20px rgba(79, 70, 229, 0.6)); }
            100% { filter: drop-shadow(0 0 10px rgba(79, 70, 229, 0.3)); }
        }

        .logo.speaking {
            animation: speaking-glow 2s infinite;
        }

        /* Add text size control styles */
        .text-size-control {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .text-size-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .text-size-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            transition: background 0.2s;
        }

        .text-size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: all 0.2s;
        }

        .text-size-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .text-size-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: var(--accent-hover);
        }

        .text-size-slider::-moz-range-thumb:hover {
            transform: scale(1.1);
            background: var(--accent-hover);
        }

        .text-size-preview {
            min-width: 3em;
            text-align: right;
            color: var(--text-primary);
        }

        /* Make response text size responsive to slider */
        .response-text {
            transition: font-size 0.2s;
        }

        .status-label {
            margin-top: 8px;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.9rem;
            min-height: 20px;
        }
        
        .status-label.success {
            color: var(--success);
            background-color: rgba(34, 197, 94, 0.1);
        }
        
        .status-label.error {
            color: var(--error);
            background-color: rgba(239, 68, 68, 0.1);
        }
        
        .status-label.info {
            color: var(--text-secondary);
            background-color: rgba(255, 255, 255, 0.05);
        }

        .mission-statement {
            background-color: var(--bg-secondary);
            border-radius: 12px;
            padding: 30px;
            margin: 20px auto;
            max-width: 100%;
            box-shadow: 0 4px 6px var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .mission-statement h2 {
            color: var(--text-primary);
            font-size: 1.8rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .mission-statement p {
            color: var(--text-secondary);
            font-size: 1.1rem;
            line-height: 1.6;
            margin: 0;
            max-width: 800px;
        }

        .mission-statement:hover {
            border-color: var(--accent);
            box-shadow: 0 8px 12px var(--shadow);
        }

        .donate-button {
            display: inline-block;
            padding: 12px 24px;
            background-color: var(--accent);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease;
            margin-top: 10px;
        }

        .donate-button:hover {
            background-color: var(--accent-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow);
        }
    </style>
</head>
<body>
    <header class="header">
        <nav class="nav">
            <div class="nav-links">
                <a href="/" class="nav-link active">Home</a>
                <a href="/utilities/speech-to-text" class="nav-link">Speech to Text</a>
                <a href="/docs" class="nav-link">API Docs</a>
            </div>
        </nav>
    </header>

    <div class="container">
        <!-- Update mission statement section -->
        <div class="mission-statement">
            <h2>Our Mission</h2>
            <p>What if there was an in-home assistant who actually was open about what they were thinking and how they were helping you? Notice that our competitors are black boxes. We're the only one that leaves it all open to you. You can see exactly what data is being processed and stored, and where. And the company behind it? A non-profit that is driven by what you are: a blood-deep genuine concern for our future if we don't take control now. Become part of the future of humanity, rather than being trampled underfoot. Let's unite, and stay, humans.</p>
            <a href="https://www.paypal.com/donate" class="donate-button" target="_blank">Donate via PayPal</a>
        </div>

        <div class="logo-container">
            <div class="logo-section">
                <img src="/assets/images/logo-good-robot-dark-1.png" alt="Good Robot Logo" class="logo" id="mainLogo">
                <h1>Voice AI Assistant</h1>
                <!-- Status Bar -->
                <div class="robot-status-bar" id="robotStatusBar">
                    <span class="robot-status" data-status="offline">Offline / Resting</span>
                    <span class="robot-status" data-status="idle">Waiting for Wake Word</span>
                    <span class="robot-status" data-status="wake">Wake Word Detected</span>
                    <span class="robot-status" data-status="listening">Listening to Understand</span>
                    <span class="robot-status" data-status="thinking">Processing / Thinking</span>
                    <span class="robot-status" data-status="responding">Responding</span>
                    <span class="robot-status" data-status="error">Error / Disconnected</span>
                </div>
            </div>
            <div class="response-section">
                <!-- Response display - now always visible -->
                <div class="response-container" id="responseContainer">
                    <div class="response-label">Assistant Response:</div>
                    <div class="response-text" id="responseText">
                        Waiting for your message...
                    </div>
                    <div class="text-size-control">
                        <div class="text-size-label tooltip-trigger">
                            Text Size
                            <span class="info-icon">ℹ️</span>
                            <div class="tooltip">
                                Adjust the size of the assistant's response text.
                                Your preference will be saved for future sessions.
                            </div>
                        </div>
                        <input type="range" 
                               class="text-size-slider" 
                               id="textSizeSlider"
                               min="16" 
                               max="72" 
                               step="1">
                        <div class="text-size-preview" id="textSizePreview">24px</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Restore transcription container -->
        <div class="transcription-container">
            <div class="transcription-label">Transcription</div>
            <div class="transcription-text" id="mainTranscription"></div>
            <div class="transcription-label" style="margin-top:8px;">Raw Transcription</div>
            <div class="transcription-text" id="rawTranscription"></div>
            <!-- Add text input area -->
            <div class="text-input-container" style="margin-top:20px;">
                <div class="transcription-label tooltip-trigger">
                    Voice Input (Simulated Speech)
                    <span class="info-icon">ℹ️</span>
                    <div class="tooltip tooltip-wide">
                        Type here to simulate speaking to the assistant. Your input will be processed exactly like voice input,
                        including wake word detection and audio processing simulation.
                    </div>
                </div>
                <div class="text-input-wrapper">
                    <textarea id="voiceInput" class="text-input" placeholder="Type here to simulate speaking..." rows="3"></textarea>
                    <button id="sendVoiceButton" class="control-button">Send as Voice</button>
                </div>
                <div id="voiceStatus" class="status-label"></div>
            </div>

            <!-- Add direct memory input area -->
            <div class="text-input-container" style="margin-top:20px;">
                <div class="transcription-label tooltip-trigger">
                    Direct Memory Input
                    <span class="info-icon">ℹ️</span>
                    <div class="tooltip tooltip-wide">
                        Type here to directly add information to the assistant's memory. This bypasses voice processing
                        and goes straight to the LLM's context. Use this for adding facts, preferences, or context.
                    </div>
                </div>
                <div class="text-input-wrapper">
                    <textarea id="memoryInput" class="text-input" placeholder="Type here to add directly to memory..." rows="3"></textarea>
                    <button id="sendMemoryButton" class="control-button">Add to Memory</button>
                </div>
                <div id="memoryStatus" class="status-label"></div>
            </div>
            <!-- Add context viewer -->
            <div class="context-viewer">
                <div class="context-header" id="contextHeader">
                    <div class="context-toggle"></div>
                    <span class="tooltip-trigger">
                        Memory Context
                        <span class="info-icon">ℹ️</span>
                        <div class="tooltip tooltip-wide">
                            View and search through conversation history and direct memory inputs. The assistant maintains:
                            • Voice and simulated voice interactions
                            • Direct memory additions
                            • Automatic topic tagging
                            • Up to 50 recent interactions
                        </div>
                    </span>
                    <span class="memory-count tooltip-trigger">
                        0 memories
                        <div class="tooltip">Maximum capacity: 50 memories (voice, text, and direct memory inputs)</div>
                    </span>
                </div>
                <div class="context-content" id="contextContent">
                    <div class="memory-filters">
                        <div class="tooltip-trigger" style="width: 100%;">
                            <input type="text" class="memory-search" placeholder="Search memories...">
                            <span class="info-icon">ℹ️</span>
                            <div class="tooltip tooltip-wide">
                                Search through all memories by typing keywords.
                                Memories are tagged automatically based on content (time, weather, identity, etc.).
                            </div>
                        </div>
                        <div class="memory-tags tooltip-trigger" id="memoryTags">
                            <span class="info-icon">ℹ️</span>
                            <div class="tooltip tooltip-wide">
                                Click tags to filter memories by topic. Available tags:
                                time, weather, identity, assistance, question, memory, conversation
                            </div>
                        </div>
                    </div>
                    <div class="memories-list tooltip-trigger" id="memoriesList">
                        <span class="info-icon">ℹ️</span>
                        <div class="tooltip tooltip-wide">
                            Recent memories are shown first. Each memory shows:
                            • Tags for quick categorization
                            • Timestamp of the interaction
                            • The actual conversation content
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="panel live-panel">
                <h2>Voice & Text AI Assistant</h2>
                <p>Interact with the assistant through voice or text. Say "Jarvis" to activate voice recognition, or use the text input areas below.</p>
                <div class="controls-row">
                    <div class="status-group">
                        <span class="status-indicator" id="statusIndicator"></span>
                        <span id="statusText">Microphone inactive</span>
                    </div>
                    <button class="control-button" id="startButton">Start Listening</button>
                    <button class="control-button" id="doneSpeakingButton" style="display: none;">Done Speaking</button>
                </div>
                
                <div class="visualizer-container">
                    <div class="volume-bar" id="volumeBar"></div>
                    <div class="noise-floor" id="noiseFloor"></div>
                </div>

                <div class="metrics-container">
                    <div class="metric-box">
                        <div class="metric-label">Volume</div>
                        <div class="metric-value" id="rmsValue">0.00</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Peak</div>
                        <div class="metric-value" id="peakValue">0.00</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">SNR</div>
                        <div class="metric-value" id="snrValue">0.00</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Floor</div>
                        <div class="metric-value" id="noiseFloorValue">-60</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Clips</div>
                        <div class="metric-value" id="clipValue">0</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Silence</div>
                        <div class="metric-value" id="silenceValue">0%</div>
                    </div>
                </div>

                <div class="voice-settings">
                    <h3 class="tooltip-trigger">
                        Voice & Text Settings
                        <span class="info-icon">ℹ️</span>
                        <div class="tooltip tooltip-wide">
                            Configure how the assistant responds to your inputs. You can:
                            • Use voice input by speaking or typing in the Voice Input area
                            • Add context directly through the Memory Input area
                            • Choose between Web Speech (free) or ElevenLabs for voice responses
                        </div>
                    </h3>
                    <div class="voice-controls">
                        <select class="voice-select tooltip-trigger" id="voiceSelect">
                            <option value="">Select Voice</option>
                            <div class="tooltip">Choose from available system voices</div>
                        </select>
                        <div class="voice-toggle tooltip-trigger" id="voiceToggle">
                            <input type="checkbox" id="voiceEnabled">
                            <label for="voiceEnabled">Enable</label>
                            <div class="tooltip">Toggle voice responses on/off</div>
                        </div>
                    </div>
                    <div class="voice-provider">
                        <div class="provider-option" data-provider="web-speech">Web Speech (Free)</div>
                        <div class="provider-option" data-provider="elevenlabs">ElevenLabs</div>
                    </div>
                    <input type="password" class="api-key-input" id="apiKeyInput" placeholder="ElevenLabs API Key" style="display: none;">
                </div>

                <div class="transcript" id="transcript"></div>

                <!-- Add debug log section -->
                <div class="debug-section">
                    <div class="debug-header tooltip-trigger" id="debugHeader">
                        <div class="debug-toggle"></div>
                        <span>Debug Log</span>
                        <span class="info-icon">ℹ️</span>
                        <div class="tooltip tooltip-wide">
                            View technical details about:
                            • Voice and text input processing
                            • Memory operations
                            • Voice recognition status
                            • WebSocket connections
                            • Error messages
                        </div>
                    </div>
                    <div class="debug-log" id="debugLog"></div>
                </div>
            </div>
            <a href="/transcribe" class="panel">
                <h2>Speech to Text</h2>
                <p>Upload an audio file and get its transcription. Supports multiple audio formats and provides accurate text output.</p>
                <span class="api-link">POST /transcribe</span>
            </a>
            <a href="/docs" class="panel">
                <h2>API Documentation</h2>
                <p>Interactive API documentation with Swagger UI. Test endpoints and explore available features.</p>
                <span class="api-link">Swagger UI</span>
            </a>
            <a href="/redoc" class="panel">
                <h2>API Reference</h2>
                <p>Detailed API reference documentation with ReDoc. View comprehensive API specifications.</p>
                <span class="api-link">ReDoc</span>
            </a>
            <a href="/health" class="panel">
                <h2>Health Check</h2>
                <p>Monitor the API's operational status. Verify if all services are functioning correctly.</p>
                <span class="api-link">GET /health</span>
            </a>
        </div>
    </div>
    <script>
        // State variables
        let isRecording = false;
        let wakeWordDetected = false;
        let lastSpeechTime = 0;
        let isSpeaking = false;
        let ws = null;
        let mediaStream = null;
        let scriptProcessor = null;
        let audioContext = null;
        let isProcessingQuestion = false;
        let currentQuestion = '';
        let questionBuffer = [];

        // Constants
        const SPEECH_COOLDOWN = 3000; // 3 seconds cooldown after speaking
        const IGNORED_PHRASES = [
            "I'm not sure I understand",
            "Could you please repeat that",
            "I didn't catch that"
        ];

        // Initialize WebSocket connection
        function initWebSocket() {
            return new Promise((resolve, reject) => {
                log('Attempting to initialize WebSocket connection');
                
                if (ws && ws.readyState === WebSocket.OPEN) {
                    log('WebSocket already connected');
                    resolve(ws);
                    return;
                }

                if (ws) {
                    log('Closing existing WebSocket connection');
                    ws.close();
                }

                log('Creating new WebSocket connection to ws://localhost:8000/ws');
                ws = new WebSocket('ws://localhost:8000/ws');
                
                ws.onopen = () => {
                    log('WebSocket connection established successfully');
                    updateStatus('online');
                    resolve(ws);
                };

                ws.onclose = (event) => {
                    log(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}`);
                    updateStatus('offline');
                    ws = null;
                };

                ws.onerror = (error) => {
                    log(`WebSocket error: ${error.message}`);
                    updateStatus('error');
                    reject(error);
                };

                ws.onmessage = handleWebSocketMessage;
            });
        }

        // Update memory context display
        function updateMemoryContext(memories) {
            log('Starting memory context update');
            log(`Received memories array: ${JSON.stringify(memories)}`);
            
            const memoriesList = document.getElementById('memoriesList');
            const memoryCount = document.querySelector('.memory-count');
            
            if (!memoriesList) {
                log('Error: memoriesList element not found');
                return;
            }
            if (!memoryCount) {
                log('Error: memoryCount element not found');
                return;
            }
            
            log('Clearing existing memories');
            memoriesList.innerHTML = '';
            
            if (!Array.isArray(memories)) {
                log('Error: memories is not an array');
                return;
            }
            
            log(`Adding ${memories.length} new memories`);
            
            // Add new memories
            memories.forEach((memory, index) => {
                log(`Processing memory ${index + 1}: ${JSON.stringify(memory)}`);
                
                const memoryItem = document.createElement('div');
                memoryItem.className = 'memory-item';
                
                const header = document.createElement('div');
                header.className = 'memory-header';
                
                const tags = document.createElement('div');
                tags.className = 'memory-tags-list';
                
                if (!Array.isArray(memory.tags)) {
                    log(`Warning: memory ${index + 1} has no tags array`);
                    memory.tags = [];
                }
                
                memory.tags.forEach(tag => {
                    const tagSpan = document.createElement('span');
                    tagSpan.className = 'memory-tag-small';
                    tagSpan.textContent = tag;
                    tags.appendChild(tagSpan);
                });
                
                const timestamp = document.createElement('span');
                timestamp.className = 'memory-timestamp';
                timestamp.textContent = new Date(memory.timestamp).toLocaleString();
                
                header.appendChild(tags);
                header.appendChild(timestamp);
                
                const content = document.createElement('div');
                content.className = 'memory-content';
                content.textContent = memory.text;
                
                memoryItem.appendChild(header);
                memoryItem.appendChild(content);
                memoriesList.appendChild(memoryItem);
                
                log(`Added memory ${index + 1} to DOM`);
            });
            
            // Update memory count
            memoryCount.textContent = `${memories.length} memories`;
            log(`Updated memory count to ${memories.length}`);
            
            // Ensure context content is visible
            const contextContent = document.getElementById('contextContent');
            if (contextContent) {
                contextContent.style.display = 'block';
                log('Made context content visible');
            }
        }

        // Handle memory input
        async function handleMemoryInput() {
            log('Memory input handler triggered');
            const text = document.getElementById('memoryInput').value.trim();
            const memoryStatus = document.getElementById('memoryStatus');
            
            log(`Memory input text: "${text}"`);
            
            if (text) {
                try {
                    log('Initializing WebSocket connection');
                    const socket = await initWebSocket();
                    log('WebSocket connection initialized successfully');
                    
                    const memoryData = {
                        type: 'memory',
                        text: text,
                        timestamp: new Date().toISOString(),
                        tags: ['user_input', 'direct_memory']
                    };
                    
                    log(`Preparing to send memory data: ${JSON.stringify(memoryData)}`);
                    
                    if (socket.readyState !== WebSocket.OPEN) {
                        throw new Error('WebSocket is not in OPEN state');
                    }
                    
                    socket.send(JSON.stringify(memoryData));
                    log('Memory data sent successfully');
                    
                    memoryStatus.textContent = `Added to memory: "${text}"`;
                    memoryStatus.className = 'status-label success';
                    
                    document.getElementById('memoryInput').value = '';
                    log('Cleared memory input field');
                    
                    setTimeout(() => {
                        memoryStatus.textContent = '';
                        memoryStatus.className = 'status-label';
                        log('Cleared memory status message');
                    }, 3000);
                } catch (error) {
                    log(`Error in memory input: ${error.message}`);
                    console.error('Memory input error:', error);
                    memoryStatus.textContent = `Error: ${error.message}`;
                    memoryStatus.className = 'status-label error';
                }
            } else {
                log('Empty memory input detected');
                memoryStatus.textContent = 'Please enter some text';
                memoryStatus.className = 'status-label error';
            }
        }

        // Handle voice input
        async function handleVoiceInput() {
            console.log('Send as Voice clicked');
            const text = document.getElementById('voiceInput').value.trim();
            const voiceStatus = document.getElementById('voiceStatus');
            
            if (text) {
                try {
                    // Initialize WebSocket if needed
                    await initWebSocket();
                    
                    // Simulate wake word detection
                    wakeWordDetected = true;
                    log('Simulated wake word detected');
                    
                    // Send the text as if it were spoken
                    ws.send(JSON.stringify({
                        type: 'transcription',
                        text: text,
                        timestamp: new Date().toISOString()
                    }));
                    
                    // Process the text as if it were spoken
                    handleTranscription(text);
                    
                    // Show success message
                    voiceStatus.textContent = `Sent as voice: "${text}"`;
                    voiceStatus.className = 'status-label success';
                    
                    // Clear the input
                    document.getElementById('voiceInput').value = '';
                    
                    // Clear status after 3 seconds
                    setTimeout(() => {
                        voiceStatus.textContent = '';
                        voiceStatus.className = 'status-label';
                    }, 3000);
                } catch (error) {
                    console.error('Voice input error:', error);
                    voiceStatus.textContent = `Error: ${error.message}`;
                    voiceStatus.className = 'status-label error';
                }
            } else {
                voiceStatus.textContent = 'Please enter some text';
                voiceStatus.className = 'status-label error';
            }
        }

        // Initialize UI elements
        document.addEventListener('DOMContentLoaded', function() {
            const responseContainer = document.getElementById('responseContainer');
            const responseText = document.getElementById('responseText');
            const startButton = document.getElementById('startButton');
            const voiceInput = document.getElementById('voiceInput');
            const sendVoiceButton = document.getElementById('sendVoiceButton');
            const memoryInput = document.getElementById('memoryInput');
            const sendMemoryButton = document.getElementById('sendMemoryButton');
            const robotStatusBar = document.getElementById('robotStatusBar');
            const textSizeSlider = document.getElementById('textSizeSlider');
            const textSizePreview = document.getElementById('textSizePreview');
            const debugLog = document.getElementById('debugLog');
            const debugHeader = document.getElementById('debugHeader');
            
            // Initialize debug log
            if (debugLog) {
                debugLog.style.display = 'block';
                debugLog.classList.add('expanded');
                log('Debug log initialized');
            }
            
            // Initialize debug header
            if (debugHeader) {
                debugHeader.addEventListener('click', function() {
                    const debugLog = document.getElementById('debugLog');
                    debugLog.style.display = debugLog.style.display === 'none' ? 'block' : 'none';
                    debugLog.classList.toggle('expanded');
                    debugHeader.querySelector('.debug-toggle').classList.toggle('expanded');
                });
                log('Debug header initialized');
            }
            
            // Set initial states
            responseText.textContent = "Waiting for your message...";
            responseContainer.classList.remove('active');
            updateStatus('offline');
            log('UI elements initialized');

            // Initialize text size slider
            if (textSizeSlider && textSizePreview) {
                // Set initial value
                const initialSize = 24; // Default size
                textSizeSlider.value = initialSize;
                textSizePreview.textContent = `${initialSize}px`;
                responseText.style.fontSize = `${initialSize}px`;
                responseContainer.style.display = 'block';

                // Add event listener for slider changes
                textSizeSlider.addEventListener('input', function() {
                    const size = this.value;
                    textSizePreview.textContent = `${size}px`;
                    responseText.style.fontSize = `${size}px`;
                    responseContainer.style.display = 'block';
                });
            }

            // Add event listener for the start button
            startButton.addEventListener('click', () => {
                if (!isRecording) {
                    startRecording();
                    startButton.textContent = 'Stop Listening';
                } else {
                    stopRecording();
                    startButton.textContent = 'Start Listening';
                }
            });

            // Add event listeners for voice input
            sendVoiceButton.addEventListener('click', handleVoiceInput);
            voiceInput.addEventListener('keydown', function(e) {
                // Check for Command+Enter (Mac) or Ctrl+Enter (Windows)
                if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                    // Allow new line
                    return;
                }
                
                // Check for Enter without modifier
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleVoiceInput();
                }
            });

            // Add event listeners for memory input
            sendMemoryButton.addEventListener('click', handleMemoryInput);
            memoryInput.addEventListener('keydown', function(e) {
                // Check for Command+Enter (Mac) or Ctrl+Enter (Windows)
                if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                    // Allow new line
                    return;
                }
                
                // Check for Enter without modifier
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleMemoryInput();
                }
            });

            // Initialize voices
            const voiceSelect = document.getElementById('voiceSelect');
            function populateVoices() {
                const voices = window.speechSynthesis.getVoices();
                voiceSelect.innerHTML = '<option value="">Select Voice</option>';
                voices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.name;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    voiceSelect.appendChild(option);
                });
            }
            
            // Populate voices when they're loaded
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = populateVoices;
            }
            
            // Initial population
            populateVoices();
        });

        function updateStatus(status) {
            const robotStatusBar = document.getElementById('robotStatusBar');
            if (!robotStatusBar) return;

            // Update all status indicators
            const statuses = robotStatusBar.querySelectorAll('.robot-status');
            statuses.forEach(s => {
                s.classList.remove('active');
                if (s.dataset.status === status) {
                    s.classList.add('active');
                }
            });

            // Update status indicator
            const statusIndicator = document.getElementById('statusIndicator');
            if (statusIndicator) {
                statusIndicator.className = 'status-indicator';
                if (status === 'online') {
                    statusIndicator.classList.add('active');
                } else if (status === 'error') {
                    statusIndicator.classList.add('error');
                }
            }

            // Update status text
            const statusText = document.getElementById('statusText');
            if (statusText) {
                switch (status) {
                    case 'online':
                        statusText.textContent = 'Microphone active';
                        break;
                    case 'offline':
                        statusText.textContent = 'Microphone inactive';
                        break;
                    case 'error':
                        statusText.textContent = 'Connection error';
                        break;
                    default:
                        statusText.textContent = 'Status: ' + status;
                }
            }
        }

        // Audio processing functions
        async function startRecording() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('getUserMedia not supported');
                }

                // Initialize audio context
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Get microphone stream
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Create script processor
                scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                const source = audioContext.createMediaStreamSource(mediaStream);
                source.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);

                // Initialize WebSocket connection
                ws = new WebSocket('ws://localhost:8000/ws');
                
                ws.onopen = () => {
                    log('WebSocket connection established');
                    updateStatus('online');
                    isRecording = true;
                    wakeWordDetected = false;
                };

                ws.onclose = () => {
                    log('WebSocket connection closed');
                    updateStatus('offline');
                    stopRecording();
                };

                ws.onerror = (error) => {
                    log('WebSocket error: ' + error.message);
                    updateStatus('error');
                };

                ws.onmessage = handleWebSocketMessage;

                // Process audio data
                scriptProcessor.onaudioprocess = (audioProcessingEvent) => {
                    if (!isRecording) return;

                    const inputData = audioProcessingEvent.inputBuffer.getChannelData(0);
                    const audioData = convertFloat32ToInt16(inputData);
                    
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(audioData);
                    }
                };

                log('Recording started');
            } catch (error) {
                log('Error starting recording: ' + error.message);
                updateStatus('error');
            }
        }

        function stopRecording() {
            try {
                isRecording = false;
                wakeWordDetected = false;

                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                    mediaStream = null;
                }

                if (scriptProcessor) {
                    scriptProcessor.disconnect();
                    scriptProcessor = null;
                }

                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }

                if (ws) {
                    ws.close();
                    ws = null;
                }

                updateStatus('offline');
                log('Recording stopped');
            } catch (error) {
                log('Error stopping recording: ' + error.message);
            }
        }

        // Helper functions
        function convertFloat32ToInt16(float32Array) {
            const int16Array = new Int16Array(float32Array.length);
            for (let i = 0; i < float32Array.length; i++) {
                const s = Math.max(-1, Math.min(1, float32Array[i]));
                int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return int16Array.buffer;
        }

        function handleTranscription(text) {
            if (!text || text.trim().length === 0) return;
            
            const voiceStatus = document.getElementById('voiceStatus');
            
            try {
                // Ignore transcriptions while speaking or during cooldown
                if (isSpeaking || (Date.now() - lastSpeechTime) < SPEECH_COOLDOWN) {
                    throw new Error('System is currently processing previous input');
                }

                // Update display
                const transcriptDiv = document.getElementById('transcript');
                transcriptDiv.textContent = text;
                
                // Process question if wake word was detected
                if (wakeWordDetected && !isProcessingQuestion) {
                    currentQuestion = text;
                    processQuestion();
                }
            } catch (error) {
                console.error('Transcription error:', error); // Debug log
                voiceStatus.textContent = `Error: ${error.message}`;
                voiceStatus.className = 'status-label error';
            }
        }

        function handleResponse(text) {
            if (!text || text.trim().length === 0) return;
            
            const responseContainer = document.getElementById('responseContainer');
            const responseText = document.getElementById('responseText');
            
            // Split the text into sentences
            const sentences = text.split(/(?<=[.!?])\s+/);
            
            if (sentences.length > 1) {
                // Display first sentence immediately
                responseText.textContent = sentences[0];
                responseContainer.classList.add('active');
                
                // Wait 2 seconds and then display the rest
                setTimeout(() => {
                    responseText.textContent = text;
                }, 2000);
            } else {
                // Single sentence, display immediately
                responseText.textContent = text;
                responseContainer.classList.add('active');
            }
            
            // Speak the response if voice is enabled
            if (document.getElementById('voiceEnabled').checked) {
                speakText(text);
            }
        }

        // Add speakText function
        function speakText(text) {
            if (!text) return;
            
            const voiceSelect = document.getElementById('voiceSelect');
            const selectedVoice = voiceSelect.value;
            
            // Create speech synthesis
            const utterance = new SpeechSynthesisUtterance(text);
            
            // Set voice if one is selected
            if (selectedVoice) {
                const voices = window.speechSynthesis.getVoices();
                const voice = voices.find(v => v.name === selectedVoice);
                if (voice) {
                    utterance.voice = voice;
                }
            }
            
            // Set speaking state
            isSpeaking = true;
            document.getElementById('mainLogo').classList.add('speaking');
            
            // Handle end of speech
            utterance.onend = () => {
                isSpeaking = false;
                document.getElementById('mainLogo').classList.remove('speaking');
                lastSpeechTime = Date.now();
            };
            
            // Handle errors
            utterance.onerror = (error) => {
                console.error('Speech synthesis error:', error);
                isSpeaking = false;
                document.getElementById('mainLogo').classList.remove('speaking');
            };
            
            // Speak the text
            window.speechSynthesis.speak(utterance);
        }

        async function processQuestion() {
            if (!currentQuestion || isProcessingQuestion) return;
            
            const voiceStatus = document.getElementById('voiceStatus');
            
            try {
                isProcessingQuestion = true;
                
                // Initialize WebSocket if needed
                await initWebSocket();
                
                // Send the question to the server
                ws.send(JSON.stringify({
                    type: 'question',
                    text: currentQuestion,
                    timestamp: new Date().toISOString()
                }));
                
                currentQuestion = '';
                isProcessingQuestion = false;
            } catch (error) {
                console.error('Question processing error:', error);
                voiceStatus.textContent = `Error: ${error.message}`;
                voiceStatus.className = 'status-label error';
                isProcessingQuestion = false;
            }
        }

        function log(message) {
            const debugLog = document.getElementById('debugLog');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${message}`;
            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        // Add handleWebSocketMessage function
        function handleWebSocketMessage(event) {
            try {
                log('WebSocket message received');
                log(`Raw message data: ${event.data}`);
                
                if (typeof event.data !== 'string') {
                    log('Received binary data, skipping JSON parsing');
                    return;
                }
                
                const data = JSON.parse(event.data);
                log(`Successfully parsed message data: ${JSON.stringify(data)}`);

                switch (data.type) {
                    case 'transcription':
                        log('Processing transcription message');
                        document.getElementById('rawTranscription').textContent = data.text;
                        handleTranscription(data.text);
                        break;
                    case 'response':
                        log('Processing response message');
                        document.getElementById('responseText').textContent = data.text;
                        handleResponse(data.text);
                        break;
                    case 'error':
                        log(`Error message received: ${data.message}`);
                        updateStatus('error');
                        break;
                    case 'status':
                        log(`Status update received: ${data.status}`);
                        updateStatus(data.status);
                        break;
                    case 'memory':
                    case 'memory_update':  // Add support for memory_update type
                        log('Memory update received');
                        if (!data.memories) {
                            log('Warning: memories array is missing in memory update');
                            return;
                        }
                        log(`Memory data: ${JSON.stringify(data.memories)}`);
                        updateMemoryContext(data.memories);
                        break;
                    default:
                        log(`Unknown message type: ${data.type}`);
                }
            } catch (error) {
                log(`Error handling WebSocket message: ${error.message}`);
                console.error('WebSocket message error:', error);
            }
        }
    </script>
</body>
</html> 