<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wake Word Sample Recorder</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/static/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon/favicon-16x16.png">
    <link rel="manifest" href="/static/favicon/site.webmanifest">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --background-color: #1a1a1a;
            --surface-color: #2d2d2d;
            --text-color: #e0e0e0;
            --border-color: #404040;
            --hover-color: #2980b9;
            --success-color: #4CAF50;
            --error-color: #ff6b6b;
            --muted-text: #a0a0a0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
                Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background: var(--background-color);
            background-image: url('/static/images/backgrounds/bg-desk-dust-1.jpg');
            background-position: center center;
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
            color: var(--text-color);
            line-height: 1.6;
            height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            flex-shrink: 0;
            width: 100%;
            padding: 1rem 2rem;
            background: var(--surface-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 100;
        }

        .header-logo {
            height: 40px;
            object-fit: contain;
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .brain-image {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }

        .header-text {
            color: var(--text-color);
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .nav-links {
            display: flex;
            gap: 1.5rem;
        }

        .nav-link {
            color: var(--text-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s;
        }

        .nav-link:hover {
            color: var(--primary-color);
        }

        .container {
            flex: 1;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 1rem;
            padding: 1rem;
            background: rgba(26, 26, 26, 0.75);
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 1;
            height: calc(100vh - 5rem);
            overflow: hidden;
            margin-bottom: 1rem;
            min-height: 0;
        }

        .column {
            position: relative;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            background: rgba(32, 32, 32, 0.95);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: 100%;
            overflow-y: auto;
            min-height: 0;
        }

        .collapsible {
            margin-bottom: 0.5rem;
        }

        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
        }

        .collapsible-content {
            padding: 0.5rem;
            display: none;
        }

        .collapsible-content.show {
            display: block;
        }

        .audio-visualizer {
            margin: 0 0 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            height: 80px;
        }
        
        #audioVisualizer {
            width: 100%;
            height: 60px;
            background: var(--surface-color);
            border-radius: 5px;
            margin-bottom: 5px;
        }

        .controls-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            width: 100%;
        }

        .button {
            padding: 0.5rem 1rem;
            height: 2.5rem;
        }

        .metric-card {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .quality-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .progress-section {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .progress-bar {
            height: 3px;
        }

        .sample-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .sample-item {
            padding: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .waveform-container {
            height: 30px;
        }

        .recording {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .quality-metric {
            transition: all 0.3s ease;
        }

        .quality-metric.good {
            color: var(--success-color);
        }

        .quality-metric.warning {
            color: #FBBF24;
        }

        .quality-metric.bad {
            color: var(--error-color);
        }

        .logs-container {
            flex: 1;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .main-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .button:disabled {
            background: var(--border-color);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .button.danger {
            background: var(--error-color);
        }

        .button.danger:hover {
            background: #e74c3c;
        }

        .button.success {
            background: var(--success-color);
        }

        .button.success:hover {
            background: #45a049;
        }

        .button.warning {
            background: #FBBF24;
            color: #1a1a1a;
        }

        .button.warning:hover {
            background: #f59e0b;
        }

        .sample-list-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            gap: 1rem;
        }

        .sort-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .filter-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .select-control {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.875rem;
        }

        .select-control option {
            background: var(--surface-color);
            color: var(--text-color);
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
        }

        .quality-indicators {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .quality-indicator {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.2);
        }

        .quality-indicator.good {
            color: var(--success-color);
            background: rgba(76, 175, 80, 0.1);
        }

        .quality-indicator.warning {
            color: #FBBF24;
            background: rgba(251, 191, 36, 0.1);
        }

        .quality-indicator.bad {
            color: var(--error-color);
            background: rgba(255, 87, 87, 0.1);
        }

        .batch-actions {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .checkbox-control {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            background: var(--surface-color);
            cursor: pointer;
        }

        .checkbox-control:checked {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .sample-duration {
            font-size: 0.75rem;
            color: var(--muted-text);
            margin-left: auto;
            padding-left: 1rem;
        }

        .recording-interface {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .volume-indicator {
            width: 100%;
            height: 20px;
            background: var(--surface-color);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .volume-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), #8BC34A);
            transition: width 0.1s ease;
        }
        
        .volume-label {
            text-align: center;
            font-size: 14px;
            color: var(--text-color);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .btn {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            transition: background 0.3s ease;
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .btn:hover:not(:disabled) {
            background: #45a049;
        }
        
        .status {
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .error {
            color: #f44336;
            text-align: center;
            margin: 10px 0;
        }

        .avatar-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            transition: transform 0.3s ease;
        }

        .avatar {
            width: 100%;
            height: 100%;
            background-image: url('/static/images/light-mode-brain-2.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            filter: brightness(0.8);
        }

        .avatar.listening {
            transform: rotate(7deg);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .log-entry {
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.2);
            font-family: monospace;
            font-size: 0.875rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .log-entry.error {
            background: rgba(255, 0, 0, 0.1);
            color: #ff6b6b;
        }

        .log-entry .timestamp {
            color: var(--muted-text);
            min-width: 80px;
        }

        .log-entry .source {
            color: var(--primary-color);
            min-width: 100px;
            text-transform: uppercase;
        }

        .log-entry .level {
            min-width: 60px;
            text-transform: uppercase;
        }

        .log-entry .level.info {
            color: #4CAF50;
        }

        .log-entry .level.warning {
            color: #FBBF24;
        }

        .log-entry .level.error {
            color: #ff6b6b;
        }

        .log-entry .level.debug {
            color: var(--muted-text);
        }

        .log-entry .message {
            flex: 1;
            word-break: break-word;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-brand">
            <img src="/static/images/light-mode-brain-2.png" alt="Brain Icon" class="brain-image">
            <span class="header-text">Good Robot</span>
        </div>
        <nav class="nav-links">
            <a href="http://localhost:3000" class="nav-link" target="_blank" rel="noopener noreferrer">Documentation</a>
            <a href="http://localhost:8000/redoc" class="nav-link" target="_blank" rel="noopener noreferrer">API Docs</a>
            <a href="http://localhost:8000/voice" class="nav-link">Voice Interface</a>
            <a href="/research" class="nav-link">Research</a>
            <a href="/sample-recorder" class="nav-link">Sample Recorder</a>
        </nav>
    </header>

    <div class="container">
        <!-- Logs Section - Left Column -->
        <div class="column">
            <div class="avatar-container">
                <div class="avatar" id="avatar"></div>
            </div>
            <h2 class="text-lg font-semibold mb-2 text-gray-200">Live Logs</h2>
            <div class="logs-container metric-card">
                <div class="font-mono text-xs">
                    <div id="logContainer" class="space-y-1 text-gray-300"></div>
                </div>
            </div>
        </div>

        <!-- Main Content - Right Column -->
        <div class="column">
            <div class="main-content">
                <h1 class="text-xl font-bold text-center mb-4 text-gray-100">Wake Word Sample Recorder</h1>
                
                <!-- Instructions Section - Collapsible -->
                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="section-title">Instructions</span>
                        <span class="toggle-icon">▼</span>
                    </div>
                    <div class="collapsible-content metric-card">
                        <p class="text-gray-300 mb-2">Recording workflow:</p>
                        <ol class="list-decimal pl-5 space-y-1 text-gray-300 text-sm">
                            <li>Click "Start Human Recording" to begin recording</li>
                            <li>Say the wake word ("jarvis") once clearly</li>
                            <li>Click "Stop Recording" when done</li>
                            <li>Use "Play Sample" to review your recording</li>
                            <li>Click "Save Sample" if good, or "Discard Sample" if not</li>
                            <li>Repeat this process until you have 5 good samples</li>
                        </ol>
                        <p class="text-gray-300 mt-2 text-sm">For AI samples, follow the same process using "Start AI Recording"</p>
                    </div>
                </div>

                <!-- Controls Section -->
                <div class="controls-section">
                    <h2 class="section-title">Recording Controls</h2>
                    
                    <!-- Audio Visualizer -->
                    <div class="audio-visualizer">
                        <canvas id="audioVisualizer" width="600" height="60"></canvas>
                        <div id="volumeIndicator" class="volume-indicator">
                            <div id="volumeBar" class="volume-bar"></div>
                        </div>
                        <div id="volumeLabel" class="volume-label">Volume Level: 0%</div>
                    </div>
                    
                    <div class="controls-grid">
                        <div class="button-group">
                            <button id="recordHuman" class="button flex-1">
                                Start Human Recording
                            </button>
                            <button id="stopRecording" class="button danger flex-1 hidden">
                                Stop Recording
                            </button>
                            <button id="playSample" class="button hidden flex-shrink-0" style="width: auto; padding-left: 1.5rem; padding-right: 1.5rem;">
                                ▶ Play
                            </button>
                        </div>
                        <div class="button-group">
                            <button id="recordAI" class="button success flex-1">
                                Start AI Recording
                            </button>
                        </div>
                    </div>
                    <div class="controls-grid">
                        <button id="saveSample" class="button success hidden">
                            Save Sample
                        </button>
                        <button id="discardSample" class="button danger hidden">
                            Discard Sample
                        </button>
                    </div>
                </div>

                <!-- Status and Progress Section -->
                <div class="controls-section">
                    <div class="progress-section">
                        <div>
                            <h2 class="section-title">Current Status</h2>
                            <div id="status" class="metric-card">
                                Ready to record
                            </div>
                        </div>
                        <div>
                            <h2 class="section-title">Progress</h2>
                            <div class="space-y-2">
                                <div>
                                    <div class="flex items-center justify-between text-sm">
                                        <span class="text-gray-300">Human Samples</span>
                                        <span id="humanProgress" class="text-gray-300">0/5</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div id="humanProgressBar" class="progress-bar-fill" style="width: 0%"></div>
                                    </div>
                                </div>
                                <div>
                                    <div class="flex items-center justify-between text-sm">
                                        <span class="text-gray-300">AI Samples</span>
                                        <span id="aiProgress" class="text-gray-300">0/5</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div id="aiProgressBar" class="progress-bar-fill" style="width: 0%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Quality Metrics Section - Collapsible -->
                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="section-title">Sample Quality Metrics</span>
                        <span class="toggle-icon">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="quality-metrics">
                            <div class="metric-card">
                                <h3 class="font-medium mb-2 text-gray-300 text-sm">Audio Quality</h3>
                                <div class="space-y-1 text-sm">
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Volume Level:</span>
                                        <span id="volumeLevel" class="quality-metric">-</span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Background Noise:</span>
                                        <span id="noiseLevel" class="quality-metric">-</span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Clarity:</span>
                                        <span id="clarityLevel" class="quality-metric">-</span>
                                    </div>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="font-medium mb-2 text-gray-300 text-sm">Validation Rules</h3>
                                <div class="space-y-1 text-sm">
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Duration:</span>
                                        <span id="durationCheck" class="quality-metric">-</span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Wake Word:</span>
                                        <span id="wakeWordCheck" class="quality-metric">-</span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Overall Quality:</span>
                                        <span id="overallQuality" class="quality-metric">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Recorded Samples Section - Collapsible -->
                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="section-title">Recorded Samples</span>
                        <span class="toggle-icon">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="sample-list">
                            <div id="samplesList">
                                <div class="no-samples">No samples recorded yet</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let mediaRecorder = null;
        let audioContext = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingType = 'human';
        let humanSamplesCount = 0;
        let aiSamplesCount = 0;
        let batchCount = 0;
        let isBatchMode = false;
        let audioPlayer;
        let recordedSamples = [];
        let currentAudio = null;
        let selectedSamples = new Set();
        let statusElement = null;
        let recordHumanBtn = null;
        let recordAIBtn = null;
        let samplesList = null;
        let socket = null;
        let playButton = null;
        let saveButton = null;
        let discardButton = null;
        let startBatchButton = null;
        let batchStatus = null;
        let batchProgress = null;
        let batchProgressBar = null;
        let humanProgress = null;
        let humanProgressBar = null;
        let aiProgress = null;
        let aiProgressBar = null;
        let analyser;
        let visualizerCanvas;
        let canvasCtx;
        let animationId;
        let volumeBar;
        let volumeLabel;

        document.addEventListener('DOMContentLoaded', () => {
            // Initialize UI elements
            recordHumanBtn = document.getElementById('recordHuman');
            recordAIBtn = document.getElementById('recordAI');
            stopRecordingBtn = document.getElementById('stopRecording');
            playButton = document.getElementById('playSample');
            saveButton = document.getElementById('saveSample');
            discardButton = document.getElementById('discardSample');
            startBatchButton = document.getElementById('startBatch');
            batchStatus = document.getElementById('batchStatus');
            batchProgress = document.getElementById('batchProgress');
            batchProgressBar = document.getElementById('batchProgressBar');
            statusElement = document.getElementById('status');
            logContainer = document.getElementById('logContainer');
            samplesList = document.getElementById('samplesList');
            humanProgress = document.getElementById('humanProgress');
            humanProgressBar = document.getElementById('humanProgressBar');
            aiProgress = document.getElementById('aiProgress');
            aiProgressBar = document.getElementById('aiProgressBar');

            // Bind event listeners
            if (recordHumanBtn) {
                recordHumanBtn.addEventListener('click', () => startRecording('human'));
            }
            if (recordAIBtn) {
                recordAIBtn.addEventListener('click', () => startRecording('ai'));
            }
            if (stopRecordingBtn) {
                stopRecordingBtn.addEventListener('click', stopRecording);
            }
            if (startBatchButton) {
                startBatchButton.addEventListener('click', startBatchMode);
            }
            if (playButton) {
                playButton.addEventListener('click', () => {
                    if (currentAudio) {
                        playRecording(currentAudio);
                    }
                });
            }
            if (saveButton) {
                saveButton.addEventListener('click', saveSample);
            }
            if (discardButton) {
                discardButton.addEventListener('click', discardRecording);
            }

            // Initialize WebSocket connection
            initializeWebSocket();

            // Load any existing samples
            loadSavedSamples();
        });

        // Helper function to safely add event listeners
        function addSafeEventListener(element, event, handler) {
            if (element && typeof handler === 'function') {
                element.addEventListener(event, handler);
            }
        }

        // Helper function to safely remove event listeners
        function removeSafeEventListener(element, event, handler) {
            if (element && typeof handler === 'function') {
                element.removeEventListener(event, handler);
            }
        }

        async function startRecording(type) {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Media devices not supported');
                }

                recordingType = type;
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                await initAudioContext(stream);
                
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    try {
                        updateStatus('Processing recording...');
                        const result = await saveSample();
                        if (result && result.success) {
                            updateStatus('Recording saved successfully');
                        } else {
                            updateStatus(result.error || 'Failed to save recording', true);
                        }
                        
                        // Clean up audio context
                        if (audioContext) {
                            cancelAnimationFrame(animationId);
                            await audioContext.close();
                            audioContext = null;
                        }
                        
                        // Reset UI
                        resetRecordingUI();
                        
                    } catch (error) {
                        console.error('Error processing recording:', error);
                        updateStatus(`Error: ${error.message}`, true);
                        resetRecordingUI();
                    }
                };
                
                mediaRecorder.start();
                isRecording = true;
                
                // Update UI
                updateRecordingUI();
                updateStatus('Recording... Speak clearly into your microphone');
                
            } catch (error) {
                console.error('Error starting recording:', error);
                updateStatus(`Error: ${error.message}`, true);
                resetRecordingUI();
                
                // Clean up on error
                if (audioContext) {
                    cancelAnimationFrame(animationId);
                    await audioContext.close();
                    audioContext = null;
                }
            }
        }

        function updateRecordingUI() {
            if (stopRecordingBtn) {
                stopRecordingBtn.classList.remove('hidden');
                stopRecordingBtn.disabled = false;
            }
            if (recordHumanBtn) {
                recordHumanBtn.classList.add('hidden');
                recordHumanBtn.disabled = true;
            }
            if (recordAIBtn) {
                recordAIBtn.classList.add('hidden');
                recordAIBtn.disabled = true;
            }
        }

        function resetRecordingUI() {
            if (stopRecordingBtn) {
                stopRecordingBtn.classList.add('hidden');
                stopRecordingBtn.disabled = true;
            }
            if (recordHumanBtn) {
                recordHumanBtn.classList.remove('hidden');
                recordHumanBtn.disabled = false;
            }
            if (recordAIBtn) {
                recordAIBtn.classList.remove('hidden');
                recordAIBtn.disabled = false;
            }
        }

        async function stopRecording() {
            try {
                if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                    throw new Error('No active recording');
                }
                
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                isRecording = false;
                
                // Disable stop button while processing
                if (stopRecordingBtn) {
                    stopRecordingBtn.disabled = true;
                }
                
            } catch (error) {
                console.error('Error stopping recording:', error);
                updateStatus(`Error: ${error.message}`, true);
                resetRecordingUI();
            }
        }

        function checkVolumeLevel(stream) {
            return new Promise((resolve, reject) => {
                const audioContext = new AudioContext();
                const source = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                let totalVolume = 0;
                let sampleCount = 0;
                let startTime = Date.now();
                
                function checkVolume() {
                    analyser.getByteFrequencyData(dataArray);
                    const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                    totalVolume += average;
                    sampleCount++;
                    
                    // Update volume display
                    const volumePercent = Math.min(100, Math.round((average / 255) * 100));
                    const volumeBar = document.getElementById('volumeBar');
                    const volumeText = document.getElementById('volumeText');
                    
                    if (volumeBar) {
                        volumeBar.style.width = `${volumePercent}%`;
                        volumeBar.className = `progress-bar ${volumePercent < 3 ? 'bg-danger' : 'bg-success'}`;
                    }
                    
                    if (volumeText) {
                        if (volumePercent < 3) {
                            volumeText.textContent = 'Speak louder!';
                        } else if (volumePercent < 5) {
                            volumeText.textContent = 'Good volume, keep going!';
                        } else {
                            volumeText.textContent = 'Perfect volume!';
                        }
                    }
                    
                    if (Date.now() - startTime >= 3000) { // Check for 3 seconds
                        const avgVolume = totalVolume / sampleCount;
                        const volumePercent = Math.min(100, Math.round((avgVolume / 255) * 100));
                        
                        if (volumePercent < 3) {
                            resolve({
                                success: false,
                                message: 'Microphone volume is too low. Please speak louder.'
                            });
                        } else {
                            resolve({
                                success: true,
                                message: 'Volume level is good!',
                                volume: volumePercent
                            });
                        }
                    } else {
                        requestAnimationFrame(checkVolume);
                    }
                }
                
                checkVolume();
            });
        }

        async function initAudioContext(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            
            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            visualizerCanvas = document.getElementById('audioVisualizer');
            canvasCtx = visualizerCanvas.getContext('2d');
            volumeBar = document.getElementById('volumeBar');
            volumeLabel = document.getElementById('volumeLabel');
            
            function draw() {
                animationId = requestAnimationFrame(draw);
                
                analyser.getByteFrequencyData(dataArray);
                
                // Calculate volume level using RMS
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const amplitude = (dataArray[i] - 128) / 128;
                    sum += amplitude * amplitude;
                }
                const rms = Math.sqrt(sum / bufferLength);
                const volume = Math.min(100, Math.round(rms * 200)); // Adjusted multiplier for better sensitivity
                
                // Update volume indicator
                volumeBar.style.width = `${volume}%`;
                volumeLabel.textContent = `Volume Level: ${volume}%`;
                
                // Update volume bar color based on level
                if (volume < 3) {
                    volumeBar.style.background = 'linear-gradient(90deg, #ff4444, #ff6b6b)'; // Red for too low
                } else if (volume > 90) {
                    volumeBar.style.background = 'linear-gradient(90deg, #ff9900, #ffbb33)'; // Orange for too high
                } else {
                    volumeBar.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)'; // Green for good
                }
                
                // Draw waveform
                canvasCtx.fillStyle = '#f5f5f5';
                canvasCtx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                canvasCtx.lineWidth = 2;
                canvasCtx.strokeStyle = volume < 3 ? '#ff4444' : (volume > 90 ? '#ff9900' : '#4CAF50');
                canvasCtx.beginPath();
                
                const sliceWidth = visualizerCanvas.width / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * visualizerCanvas.height / 2;
                    
                    if (i === 0) {
                        canvasCtx.moveTo(x, y);
                    } else {
                        canvasCtx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                canvasCtx.lineTo(visualizerCanvas.width, visualizerCanvas.height / 2);
                canvasCtx.stroke();
                
                // Add volume threshold indicators
                const lowThresholdY = visualizerCanvas.height * 0.9; // 10% from bottom
                const highThresholdY = visualizerCanvas.height * 0.1; // 10% from top
                
                // Draw low threshold line
                canvasCtx.beginPath();
                canvasCtx.strokeStyle = '#ff4444';
                canvasCtx.setLineDash([5, 5]);
                canvasCtx.moveTo(0, lowThresholdY);
                canvasCtx.lineTo(visualizerCanvas.width, lowThresholdY);
                canvasCtx.stroke();
                
                // Draw high threshold line
                canvasCtx.beginPath();
                canvasCtx.strokeStyle = '#ff9900';
                canvasCtx.moveTo(0, highThresholdY);
                canvasCtx.lineTo(visualizerCanvas.width, highThresholdY);
                canvasCtx.stroke();
                
                canvasCtx.setLineDash([]);
            }
            
            draw();
        }

        function initializeWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                
                socket = new WebSocket(wsUrl);
                
                socket.onopen = () => {
                    console.log('WebSocket connection established');
                    updateStatus('Connected to server');
                    addLogEntry('WebSocket connection established', false, 'client', 'INFO');
                };
                
                socket.onclose = () => {
                    console.log('WebSocket connection closed');
                    updateStatus('Disconnected from server');
                    addLogEntry('WebSocket connection closed', false, 'client', 'INFO');
                    // Attempt to reconnect after 5 seconds
                    setTimeout(initializeWebSocket, 5000);
                };
                
                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('Connection error');
                    addLogEntry(`WebSocket error: ${error.message}`, true, 'client', 'ERROR');
                };
                
                socket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'log') {
                            addLogEntry(data.message, data.level === 'ERROR', data.source, data.level);
                        } else {
                            handleWebSocketMessage(data);
                        }
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                        addLogEntry(`Error parsing WebSocket message: ${error.message}`, true, 'client', 'ERROR');
                    }
                };
            } catch (error) {
                console.error('Error initializing WebSocket:', error);
                updateStatus('Failed to connect to server');
                addLogEntry(`Error initializing WebSocket: ${error.message}`, true, 'client', 'ERROR');
            }
        }

        function handleWebSocketMessage(data) {
            try {
                if (data.type === 'processing_complete') {
                    updateStatus(`Processing complete: ${data.message}`);
                } else if (data.type === 'error') {
                    updateStatus(`Error: ${data.message}`, true);
                }
            } catch (error) {
                console.error('Error handling WebSocket message:', error);
            }
        }

        function updateStatus(message, isError = false) {
            if (!statusElement) return;
            
            statusElement.textContent = message;
            statusElement.className = isError ? 'status error' : 'status';
        }

        function startBatchMode() {
            try {
                if (isRecording) {
                    updateStatus('Cannot start batch mode while recording', true);
                    return;
                }

                if (isBatchMode) {
                    // Stop batch mode
                    resetBatchMode();
                    return;
                }

                isBatchMode = true;
                batchCount = 0;
                updateStatus('Starting batch recording mode...');

                if (startBatchButton) {
                    startBatchButton.textContent = 'Stop Batch Mode';
                    startBatchButton.classList.add('danger');
                }

                if (batchStatus) {
                    batchStatus.textContent = 'Recording in batch mode';
                }

                // Start the first recording
                startNextBatchRecording();
            } catch (error) {
                console.error('Error starting batch mode:', error);
                updateStatus('Error starting batch mode', true);
                resetBatchMode();
            }
        }

        function startNextBatchRecording() {
            if (!isBatchMode) return;

            // Alternate between human and AI recordings
            const type = batchCount % 2 === 0 ? 'human' : 'ai';
            startRecording(type);

            // Update progress
            if (batchProgress && batchProgressBar) {
                batchProgress.textContent = `${batchCount}/10`;
                batchProgressBar.style.width = `${(batchCount / 10) * 100}%`;
            }
        }

        function handleBatchSuccess() {
            batchCount++;
            
            if (batchCount >= 10) {
                // Batch complete
                updateStatus('Batch recording complete!');
                resetBatchMode();
                return;
            }

            // Short delay before next recording
            setTimeout(() => {
                updateStatus('Starting next batch recording...');
                startNextBatchRecording();
            }, 1000);
        }

        function handleBatchError() {
            updateStatus('Error in batch recording', true);
            resetBatchMode();
        }

        function resetBatchMode() {
            isBatchMode = false;
            batchCount = 0;

            if (startBatchButton) {
                startBatchButton.textContent = 'Start Batch Recording';
                startBatchButton.classList.remove('danger');
            }

            if (batchStatus) {
                batchStatus.textContent = 'Ready for batch recording';
            }

            if (batchProgress && batchProgressBar) {
                batchProgress.textContent = '0/10';
                batchProgressBar.style.width = '0%';
            }

            resetSampleUI();
        }

        async function saveSample() {
            try {
                if (audioChunks.length === 0) {
                    throw new Error('No audio recorded');
                }

                const blob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });
                const formData = new FormData();
                formData.append('audio', blob);
                formData.append('type', recordingType);
                formData.append('timestamp', new Date().toISOString());

                const response = await fetch('/api/process_sample', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to save sample');
                }

                updateStatus('Sample saved successfully');

                // Update progress counters
                if (recordingType === 'human') {
                    humanSamplesCount++;
                    if (humanProgress && humanProgressBar) {
                        humanProgress.textContent = `${humanSamplesCount}/5`;
                        humanProgressBar.style.width = `${(humanSamplesCount / 5) * 100}%`;
                    }
                } else {
                    aiSamplesCount++;
                    if (aiProgress && aiProgressBar) {
                        aiProgress.textContent = `${aiSamplesCount}/5`;
                        aiProgressBar.style.width = `${(aiSamplesCount / 5) * 100}%`;
                    }
                }

                // Handle batch mode success
                if (isBatchMode) {
                    handleBatchSuccess();
                } else {
                    resetSampleUI();
                }

                // Reload the samples list
                await loadSavedSamples();
                return data;
                
            } catch (error) {
                console.error('Error saving sample:', error);
                updateStatus(`Error: ${error.message}`, true);
                if (isBatchMode) {
                    handleBatchError();
                }
                throw error;
            }
        }

        async function loadSavedSamples() {
            try {
                const response = await fetch('/api/list_samples');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                const samples = data.samples || [];
                
                if (!samplesList) {
                    throw new Error('Samples list element not found');
                }
                
                recordedSamples = samples;
                samplesList.innerHTML = '';
                
                if (samples.length === 0) {
                    samplesList.innerHTML = '<div class="no-samples">No samples recorded yet</div>';
                    return;
                }
                
                samples.forEach(sample => addSampleToList(sample));
            } catch (error) {
                console.error('Error loading samples:', error);
            }
        }

        function addSampleToList(sample) {
            const template = document.getElementById('sampleItemTemplate');
            const samplesList = document.getElementById('samplesList');
            const noSamplesMsg = samplesList.querySelector('.no-samples');
            
            if (noSamplesMsg) {
                noSamplesMsg.remove();
            }

            const clone = template.content.cloneNode(true);
            const sampleItem = clone.querySelector('.sample-item');
            sampleItem.dataset.filename = sample.filename;
            
            const typeSpan = sampleItem.querySelector('.sample-type');
            typeSpan.textContent = sample.type.toUpperCase();
            typeSpan.classList.add(sample.type.toLowerCase());
            
            const timestamp = sampleItem.querySelector('.sample-timestamp');
            timestamp.textContent = new Date(sample.timestamp).toLocaleTimeString();
            
            const duration = sampleItem.querySelector('.sample-duration');
            duration.textContent = formatDuration(sample.duration || 0);
            
            // Update quality indicators
            const indicators = sampleItem.querySelectorAll('.quality-indicator');
            updateQualityIndicator(indicators[0], sample.metrics?.volume || 0);
            updateQualityIndicator(indicators[1], 1 - (sample.metrics?.noise || 0));
            updateQualityIndicator(indicators[2], sample.metrics?.clarity || 0);
            updateQualityIndicator(indicators[3], sample.metrics?.wake_word || false, 'boolean');
            
            // Draw waveform if data available
            if (sample.waveform) {
                const canvas = sampleItem.querySelector('.waveform-canvas');
                drawWaveform(canvas, sample.waveform);
            }
            
            const playButton = sampleItem.querySelector('.play');
            playButton.addEventListener('click', () => playSample(sample));
            
            const deleteButton = sampleItem.querySelector('.delete');
            deleteButton.addEventListener('click', () => deleteSample(sample, sampleItem));
            
            const checkbox = sampleItem.querySelector('.sample-checkbox');
            checkbox.addEventListener('change', updateBatchActions);
            
            samplesList.appendChild(sampleItem);
        }

        async function deleteSample(sample, element) {
            try {
                const response = await fetch(`/api/delete_sample/${sample.filename}`, {
                    method: 'DELETE'
                });

                if (!response.ok) throw new Error('Failed to delete sample');

                element.remove();
                recordedSamples = recordedSamples.filter(s => s.filename !== sample.filename);
                
                const samplesList = document.getElementById('samplesList');
                if (samplesList.children.length === 0) {
                    samplesList.innerHTML = '<div class="no-samples">No samples recorded yet</div>';
                }

                // Update progress if needed
                if (sample.type.toLowerCase() === 'human') {
                    humanSamplesCount = Math.max(0, humanSamplesCount - 1);
                    humanProgress.textContent = `${humanSamplesCount}/5`;
                    humanProgressBar.style.width = `${(humanSamplesCount / 5) * 100}%`;
                } else {
                    aiSamplesCount = Math.max(0, aiSamplesCount - 1);
                    aiProgress.textContent = `${aiSamplesCount}/5`;
                    aiProgressBar.style.width = `${(aiSamplesCount / 5) * 100}%`;
                }
            } catch (error) {
                console.error('Error deleting sample:', error);
                updateStatus('Error deleting sample', true);
            }
        }

        function resetSampleUI() {
            if (recordHumanBtn) {
                recordHumanBtn.textContent = 'Start Human Recording';
                recordHumanBtn.classList.remove('danger', 'hidden');
            }
            if (recordAIBtn) {
                recordAIBtn.textContent = 'Start AI Recording';
                recordAIBtn.classList.remove('danger', 'hidden');
            }
            if (playButton) playButton.classList.add('hidden');
            if (saveButton) saveButton.classList.add('hidden');
            if (discardButton) discardButton.classList.add('hidden');
            
            if (statusElement) {
                statusElement.textContent = 'Ready to record';
            }
        }

        function discardRecording() {
            try {
                // Clean up audio resources
                if (audioContext) {
                    cancelAnimationFrame(animationId);
                    audioContext.close();
                    audioContext = null;
                }

                // Reset audio chunks
                audioChunks = [];
                currentAudio = null;

                // Reset UI
                resetRecordingUI();
                resetSampleUI();

                // Update status
                updateStatus('Recording discarded');
                addLogEntry('Recording discarded', false, 'client', 'INFO');

            } catch (error) {
                console.error('Error discarding recording:', error);
                updateStatus(`Error discarding recording: ${error.message}`, true);
                addLogEntry(`Error discarding recording: ${error.message}`, true, 'client', 'ERROR');
            }
        }

        function updateMetricsDisplay(metrics) {
            const metricsDisplay = document.getElementById('metrics-display');
            metricsDisplay.classList.remove('hidden');
            
            // Update progress bars and values
            document.getElementById('volume-bar').style.width = `${metrics.volume_level}%`;
            document.getElementById('volume-value').textContent = `${metrics.volume_level}%`;
            
            document.getElementById('snr-bar').style.width = `${metrics.signal_to_noise}%`;
            document.getElementById('snr-value').textContent = `${metrics.signal_to_noise}%`;
            
            document.getElementById('clarity-bar').style.width = `${metrics.clarity}%`;
            document.getElementById('clarity-value').textContent = `${metrics.clarity}%`;
            
            document.getElementById('quality-bar').style.width = `${metrics.quality_score}%`;
            document.getElementById('quality-value').textContent = `${metrics.quality_score}%`;
            
            // Show/hide clipping warning
            const clippingWarning = document.getElementById('clipping-warning');
            if (metrics.clipping_percentage > 1) {
                clippingWarning.classList.remove('hidden');
                clippingWarning.textContent = `Warning: ${metrics.clipping_percentage}% of audio is clipping`;
            } else {
                clippingWarning.classList.add('hidden');
            }
        }

        // Update the handleAudioData function to display metrics
        async function handleAudioData(audioBlob, timestamp) {
            try {
                const formData = new FormData();
                formData.append('audio', audioBlob);
                formData.append('timestamp', timestamp);
                formData.append('type', 'recording');
                
                const response = await fetch('/save-sample', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                if (result.success) {
                    showMessage('Sample saved successfully', 'success');
                    updateMetricsDisplay(result.metrics);
                } else {
                    showMessage(result.error || 'Failed to save sample', 'error');
                }
            } catch (error) {
                console.error('Error saving sample:', error);
                showMessage('Error saving sample', 'error');
            }
        }

        // Add this function to handle collapsible sections
        function toggleCollapsible(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.toggle-icon');
            
            if (content.classList.contains('show')) {
                content.classList.remove('show');
                icon.textContent = '▼';
            } else {
                content.classList.add('show');
                icon.textContent = '▲';
            }
        }

        function playRecording(audioBlob) {
            const avatar = document.getElementById('avatar');
            avatar.classList.add('listening');
            
            const audio = new Audio(URL.createObjectURL(audioBlob));
            audio.onended = () => {
                avatar.classList.remove('listening');
            };
            audio.play();
        }

        async function playSample(sample) {
            try {
                const response = await fetch(`/api/get_sample/${sample.filename}`);
                if (!response.ok) throw new Error('Failed to fetch sample');
                
                const blob = await response.blob();
                playRecording(blob);
            } catch (error) {
                console.error('Error playing sample:', error);
                updateStatus('Error playing sample', true);
            }
        }

        function addLogEntry(message, isError = false, source = 'client', level = 'INFO') {
            if (!logContainer) return;
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${isError ? 'error' : ''}`;
            
            const timestamp = new Date().toLocaleTimeString();
            const sourceClass = source.toLowerCase().replace(/[^a-z0-9]/g, '-');
            
            logEntry.innerHTML = `
                <span class="timestamp">[${timestamp}]</span>
                <span class="source ${sourceClass}">${source}</span>
                <span class="level ${level.toLowerCase()}">${level}</span>
                <span class="message">${message}</span>
            `;
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Keep only the last 100 log entries
            while (logContainer.children.length > 100) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }
    </script>
</body>
</html> 



