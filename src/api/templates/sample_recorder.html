<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wake Word Sample Recorder</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/static/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon/favicon-16x16.png">
    <link rel="manifest" href="/static/favicon/site.webmanifest">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --background-color: #1a1a1a;
            --surface-color: #2d2d2d;
            --text-color: #e0e0e0;
            --border-color: #404040;
            --hover-color: #2980b9;
            --success-color: #4CAF50;
            --error-color: #ff6b6b;
            --muted-text: #a0a0a0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
                Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background: var(--background-color);
            background-image: url('/static/images/backgrounds/bg-desk-dust-1.jpg');
            background-position: center center;
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
            color: var(--text-color);
            line-height: 1.6;
            height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            flex-shrink: 0;
            width: 100%;
            padding: 1rem 2rem;
            background: var(--surface-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 100;
        }

        .header-logo {
            height: 40px;
            object-fit: contain;
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .brain-image {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }

        .header-text {
            color: var(--text-color);
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .nav-links {
            display: flex;
            gap: 1.5rem;
        }

        .nav-link {
            color: var(--text-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s;
        }

        .nav-link:hover {
            color: var(--primary-color);
        }

        .container {
            flex: 1;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 1rem;
            padding: 1rem;
            background: rgba(26, 26, 26, 0.75);
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 1;
            height: calc(100vh - 5rem);
            overflow: hidden;
            margin-bottom: 1rem;
            min-height: 0;
        }

        .column {
            position: relative;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            background: rgba(32, 32, 32, 0.95);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: 100%;
            overflow-y: auto;
            min-height: 0;
        }

        .collapsible {
            margin-bottom: 0.5rem;
        }

        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
        }

        .collapsible-content {
            padding: 0.5rem;
            display: none;
        }

        .collapsible-content.show {
            display: block;
        }

        .audio-visualizer {
            margin: 0 0 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            height: 80px;
        }
        
        #audioVisualizer {
            width: 100%;
            height: 60px;
            background: var(--surface-color);
            border-radius: 5px;
            margin-bottom: 5px;
        }

        .controls-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            width: 100%;
        }

        .button {
            padding: 0.5rem 1rem;
            height: 2.5rem;
        }

        .metric-card {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .quality-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .progress-section {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .progress-bar {
            height: 3px;
        }

        .sample-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .sample-item {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
        }

        .sample-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .sample-type {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        .sample-type.human {
            background: var(--primary-color);
            color: white;
        }

        .sample-type.ai {
            background: var(--success-color);
            color: white;
        }

        .sample-timestamp {
            color: var(--muted-text);
            font-size: 0.8rem;
        }

        .sample-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        .metric {
            font-size: 0.8rem;
            color: var(--text-color);
        }

        .sample-controls {
            display: flex;
            gap: 0.5rem;
        }

        .play-button, .delete-button {
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .play-button {
            background: var(--primary-color);
            color: white;
        }

        .play-button:hover {
            background: var(--hover-color);
        }

        .delete-button {
            background: var(--error-color);
            color: white;
        }

        .delete-button:hover {
            background: #ff3333;
        }

        #logsList {
            padding: 0.5rem;
            height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.8rem;
        }

        .log-entry {
            padding: 0.25rem;
            border-bottom: 1px solid var(--border-color);
            white-space: pre-wrap;
            word-break: break-word;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: var(--muted-text);
        }

        .log-source {
            color: var(--primary-color);
        }

        .log-level {
            color: var(--success-color);
        }

        .log-level.error {
            color: var(--error-color);
        }

        .log-message {
            margin-left: 0.5rem;
            color: var(--text-color);
        }

        .error .log-message {
            color: var(--error-color);
        }

        .info .log-message {
            color: var(--text-color);
        }

        .warning .log-message {
            color: #ff9900;
        }

        .no-samples {
            text-align: center;
            padding: 2rem;
            color: var(--muted-text);
            font-style: italic;
        }

        .recording {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .quality-metric {
            transition: all 0.3s ease;
        }

        .quality-metric.good {
            color: var(--success-color);
        }

        .quality-metric.warning {
            color: #FBBF24;
        }

        .quality-metric.bad {
            color: var(--error-color);
        }

        .logs-container {
            flex: 1;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .main-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .button:disabled {
            background: var(--border-color);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .button.danger {
            background: var(--error-color);
        }

        .button.danger:hover {
            background: #e74c3c;
        }

        .button.success {
            background: var(--success-color);
        }

        .button.success:hover {
            background: #45a049;
        }

        .button.warning {
            background: #FBBF24;
            color: #1a1a1a;
        }

        .button.warning:hover {
            background: #f59e0b;
        }

        .sample-list-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            gap: 1rem;
        }

        .sort-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .filter-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .select-control {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.875rem;
        }

        .select-control option {
            background: var(--surface-color);
            color: var(--text-color);
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
        }

        .quality-indicators {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .quality-indicator {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.2);
        }

        .quality-indicator.good {
            color: var(--success-color);
            background: rgba(76, 175, 80, 0.1);
        }

        .quality-indicator.warning {
            color: #FBBF24;
            background: rgba(251, 191, 36, 0.1);
        }

        .quality-indicator.bad {
            color: var(--error-color);
            background: rgba(255, 87, 87, 0.1);
        }

        .batch-actions {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .checkbox-control {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            background: var(--surface-color);
            cursor: pointer;
        }

        .checkbox-control:checked {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .sample-duration {
            font-size: 0.75rem;
            color: var(--muted-text);
            margin-left: auto;
            padding-left: 1rem;
        }

        .recording-interface {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .volume-indicator {
            width: 100%;
            height: 20px;
            background: var(--surface-color);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .volume-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), #8BC34A);
            transition: width 0.1s ease;
        }
        
        .volume-label {
            text-align: center;
            font-size: 14px;
            color: var(--text-color);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .btn {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            transition: background 0.3s ease;
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .btn:hover:not(:disabled) {
            background: #45a049;
        }
        
        .status {
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .error {
            color: #f44336;
            text-align: center;
            margin: 10px 0;
        }

        .avatar-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            transition: transform 0.3s ease;
        }

        .avatar {
            width: 100%;
            height: 100%;
            background-image: url('/static/images/light-mode-brain-2.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            filter: brightness(0.8);
        }

        .avatar.listening {
            transform: rotate(7deg);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .log-entry {
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.2);
            font-family: monospace;
            font-size: 0.875rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .log-entry.error {
            background: rgba(255, 0, 0, 0.1);
            color: #ff6b6b;
        }

        .log-entry .timestamp {
            color: var(--muted-text);
            min-width: 80px;
        }

        .log-entry .source {
            color: var(--primary-color);
            min-width: 100px;
            text-transform: uppercase;
        }

        .log-entry .level {
            min-width: 60px;
            text-transform: uppercase;
        }

        .log-entry .level.info {
            color: #4CAF50;
        }

        .log-entry .level.warning {
            color: #FBBF24;
        }

        .log-entry .level.error {
            color: #ff6b6b;
        }

        .log-entry .level.debug {
            color: var(--muted-text);
        }

        .log-entry .message {
            flex: 1;
            word-break: break-word;
        }

        .recorded-samples {
            margin-top: 2rem;
            background: #1e1e1e;
            border-radius: 8px;
            padding: 1rem;
            max-height: 600px;
            overflow-y: auto;
        }

        .sample-row {
            background: #2a2a2a;
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            font-size: 0.9rem;
            line-height: 1.2;
        }

        .sample-row .metrics {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            flex: 1;
        }

        .sample-row .metric {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
        }

        .sample-row .actions {
            display: flex;
            gap: 0.5rem;
        }

        .sample-row button {
            padding: 0.25rem 0.75rem;
            font-size: 0.85rem;
        }

        .sample-type {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: uppercase;
            margin-right: 0.5rem;
        }

        .sample-type.human {
            background: #2c5282;
            color: #ebf8ff;
        }

        .sample-type.ai {
            background: #2d3748;
            color: #e2e8f0;
        }

        .waveform {
            flex: 1;
            height: 40px;
            background: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .recorded-samples::-webkit-scrollbar {
            width: 8px;
        }

        .recorded-samples::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }

        .recorded-samples::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 4px;
        }

        .recorded-samples::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .section-header {
            cursor: pointer;
            padding: 0.5rem;
            background: #2a2a2a;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .section-content.open {
            max-height: 800px;
        }
    </style>
</head>
<body>
    <header class="header">
        <a href="/" class="logo" style="text-decoration: none;">
            <img src="/static/images/light-mode-brain-2.png" alt="Brain Icon" class="brain-image">
            <span class="header-text">Good Robot</span>
        </a>
        <nav class="nav-links">
            <a href="/docs" class="nav-link" target="_blank" rel="noopener noreferrer">API Docs</a>
            <a href="http://localhost:3000" class="nav-link" target="_blank" rel="noopener noreferrer">Documentation</a>
            <a href="/voice" class="nav-link">Voice Interface</a>
            <a href="/research" class="nav-link">Research</a>
            <a href="/sample-recorder" class="nav-link">Sample Recorder</a>
        </nav>
    </header>

    <div class="container">
        <!-- Logs Section - Left Column -->
        <div class="column">
            <div class="avatar-container">
                <div class="avatar" id="avatar"></div>
            </div>
            <h2 class="text-lg font-semibold mb-2 text-gray-200">Live Logs</h2>
            <div class="logs-container metric-card">
                <div class="font-mono text-xs">
                    <div id="logContainer" class="space-y-1 text-gray-300"></div>
                </div>
            </div>
        </div>

        <!-- Main Content - Right Column -->
        <div class="column">
            <div class="main-content">
                <h1 class="text-xl font-bold text-center mb-4 text-gray-100">Wake Word Sample Recorder</h1>
                
                <!-- Instructions Section - Collapsible -->
                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="section-title">Instructions</span>
                        <span class="toggle-icon">▼</span>
                    </div>
                    <div class="collapsible-content metric-card">
                        <p class="text-gray-300 mb-2">Recording workflow:</p>
                        <ol class="list-decimal pl-5 space-y-1 text-gray-300 text-sm">
                            <li>Click "Start Human Recording" to begin recording</li>
                            <li>Say the wake word ("jarvis") once clearly</li>
                            <li>Click "Stop Recording" when done</li>
                            <li>Use "Play Sample" to review your recording</li>
                            <li>Click "Save Sample" if good, or "Discard Sample" if not</li>
                            <li>Repeat this process until you have 5 good samples</li>
                        </ol>
                        <p class="text-gray-300 mt-2 text-sm">For AI samples, follow the same process using "Start AI Recording"</p>
                    </div>
                </div>

                <!-- Controls Section -->
                <div class="controls-section">
                    <h2 class="section-title">Recording Controls</h2>
                    
                    <!-- Audio Visualizer -->
                    <div class="audio-visualizer">
                        <canvas id="audioVisualizer" width="600" height="60"></canvas>
                        <div id="volumeIndicator" class="volume-indicator">
                            <div id="volumeBar" class="volume-bar"></div>
                        </div>
                        <div id="volumeLabel" class="volume-label">Volume Level: 0%</div>
                    </div>
                    
                    <div class="controls-grid">
                        <div class="button-group">
                            <button id="recordHuman" class="button flex-1">
                                Start Human Recording
                            </button>
                            <button id="stopRecording" class="button danger flex-1 hidden">
                                Stop Recording
                            </button>
                            <button id="playSample" class="button hidden flex-shrink-0" style="width: auto; padding-left: 1.5rem; padding-right: 1.5rem;">
                                ▶ Play
                            </button>
                        </div>
                        <div class="button-group">
                            <button id="recordAI" class="button success flex-1">
                                Start AI Recording
                            </button>
                        </div>
                    </div>
                    <div class="controls-grid">
                        <button id="saveSample" class="button success hidden">
                            Save Sample
                        </button>
                        <button id="discardSample" class="button danger hidden">
                            Discard Sample
                        </button>
                    </div>
                </div>

                <!-- Status and Progress Section -->
                <div class="controls-section">
                    <div class="progress-section">
                        <div>
                            <h2 class="section-title">Current Status</h2>
                            <div id="status" class="metric-card">
                                Ready to record
                            </div>
                        </div>
                        <div>
                            <h2 class="section-title">Progress</h2>
                            <div class="space-y-2">
                                <div>
                                    <div class="flex items-center justify-between text-sm">
                                        <span class="text-gray-300">Human Samples</span>
                                        <span id="humanProgress" class="text-gray-300">0/5</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div id="humanProgressBar" class="progress-bar-fill" style="width: 0%"></div>
                                    </div>
                                </div>
                                <div>
                                    <div class="flex items-center justify-between text-sm">
                                        <span class="text-gray-300">AI Samples</span>
                                        <span id="aiProgress" class="text-gray-300">0/5</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div id="aiProgressBar" class="progress-bar-fill" style="width: 0%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Quality Metrics Section - Collapsible -->
                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="section-title">Sample Quality Metrics</span>
                        <span class="toggle-icon">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="quality-metrics">
                            <div class="metric-card">
                                <h3 class="font-medium mb-2 text-gray-300 text-sm">Audio Quality</h3>
                                <div class="space-y-1 text-sm">
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Volume Level:</span>
                                        <span id="volumeLevel" class="quality-metric">-</span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Background Noise:</span>
                                        <span id="noiseLevel" class="quality-metric">-</span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Clarity:</span>
                                        <span id="clarityLevel" class="quality-metric">-</span>
                                    </div>
                                </div>
                            </div>
                            <div class="metric-card">
                                <h3 class="font-medium mb-2 text-gray-300 text-sm">Validation Rules</h3>
                                <div class="space-y-1 text-sm">
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Duration:</span>
                                        <span id="durationCheck" class="quality-metric">-</span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Wake Word:</span>
                                        <span id="wakeWordCheck" class="quality-metric">-</span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Overall Quality:</span>
                                        <span id="overallQuality" class="quality-metric">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Recorded Samples Section - Collapsible -->
                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="section-title">Recorded Samples</span>
                        <span class="toggle-icon">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="recorded-samples">
                            <div id="samplesList">
                                <div class="no-samples">No samples recorded yet</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let mediaRecorder = null;
        let audioContext = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingType = 'human';
        let humanSamplesCount = 0;
        let aiSamplesCount = 0;
        let batchCount = 0;
        let isBatchMode = false;
        let audioPlayer;
        let recordedSamples = [];
        let currentAudio = null;
        let selectedSamples = new Set();
        let statusElement = null;
        let recordHumanBtn = null;
        let recordAIBtn = null;
        let samplesList = null;
        let socket = null;
        let playButton = null;
        let saveButton = null;
        let discardButton = null;
        let startBatchButton = null;
        let batchStatus = null;
        let batchProgress = null;
        let batchProgressBar = null;
        let humanProgress = null;
        let humanProgressBar = null;
        let aiProgress = null;
        let aiProgressBar = null;
        let analyser;
        let visualizerCanvas;
        let canvasCtx;
        let animationId;
        let volumeBar;
        let volumeLabel;

        document.addEventListener('DOMContentLoaded', () => {
            // Initialize UI elements
            recordHumanBtn = document.getElementById('recordHuman');
            recordAIBtn = document.getElementById('recordAI');
            stopRecordingBtn = document.getElementById('stopRecording');
            playButton = document.getElementById('playSample');
            saveButton = document.getElementById('saveSample');
            discardButton = document.getElementById('discardSample');
            startBatchButton = document.getElementById('startBatch');
            batchStatus = document.getElementById('batchStatus');
            batchProgress = document.getElementById('batchProgress');
            batchProgressBar = document.getElementById('batchProgressBar');
            statusElement = document.getElementById('status');
            logContainer = document.getElementById('logContainer');
            samplesList = document.getElementById('samplesList');
            humanProgress = document.getElementById('humanProgress');
            humanProgressBar = document.getElementById('humanProgressBar');
            aiProgress = document.getElementById('aiProgress');
            aiProgressBar = document.getElementById('aiProgressBar');

            // Bind event listeners
            if (recordHumanBtn) {
                recordHumanBtn.addEventListener('click', () => startRecording('human'));
            }
            if (recordAIBtn) {
                recordAIBtn.addEventListener('click', () => startRecording('ai'));
            }
            if (stopRecordingBtn) {
                stopRecordingBtn.addEventListener('click', stopRecording);
            }
            if (startBatchButton) {
                startBatchButton.addEventListener('click', startBatchMode);
            }
            if (playButton) {
                playButton.addEventListener('click', playRecording);
            }
            if (saveButton) {
                saveButton.addEventListener('click', saveSample);
            }
            if (discardButton) {
                discardButton.addEventListener('click', discardRecording);
            }

            // Initialize WebSocket connection
            initializeWebSocket();

            // Load any existing samples
            loadSavedSamples();
        });

        function stopRecording() {
            try {
                if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                    throw new Error('No active recording');
                }
                
                // Stop the media recorder
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                isRecording = false;
                
                // Disable stop button
                if (stopRecordingBtn) {
                    stopRecordingBtn.disabled = true;
                    stopRecordingBtn.classList.add('hidden');
                }

                // Re-enable recording buttons
                if (recordHumanBtn) {
                    recordHumanBtn.classList.remove('hidden');
                    recordHumanBtn.disabled = false;
                }
                if (recordAIBtn) {
                    recordAIBtn.classList.remove('hidden');
                    recordAIBtn.disabled = false;
                }
                
                updateStatus('Processing recording...');
                
            } catch (error) {
                console.error('Error stopping recording:', error);
                updateStatus(`Error: ${error.message}`, true);
                resetRecordingUI();
            }
        }

        function updateRecordingUI() {
            if (stopRecordingBtn) {
                stopRecordingBtn.classList.remove('hidden');
                stopRecordingBtn.disabled = false;
            }
            if (recordHumanBtn) {
                recordHumanBtn.classList.add('hidden');
                recordHumanBtn.disabled = true;
            }
            if (recordAIBtn) {
                recordAIBtn.classList.add('hidden');
                recordAIBtn.disabled = true;
            }
            // Hide save/discard while recording
            if (saveButton) {
                saveButton.classList.add('hidden');
                saveButton.disabled = true;
            }
            if (discardButton) {
                discardButton.classList.add('hidden');
                discardButton.disabled = true;
            }
            if (playButton) {
                playButton.classList.add('hidden');
                playButton.disabled = true;
            }
        }

        function startRecording(type) {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Media devices not supported');
                }

                recordingType = type;
                audioChunks = []; // Clear any previous recording
                currentAudio = null; // Clear any previous audio

                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        mediaRecorder = new MediaRecorder(stream);
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };

                        mediaRecorder.onstop = () => {
                            const blob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });
                            currentAudio = blob; // Store the blob for later use
                            handleRecordingComplete(blob);
                        };

                        // Start recording
                        mediaRecorder.start();
                        isRecording = true;
                        updateRecordingUI();
                        updateStatus('Recording... Speak clearly into your microphone');
                        
                        // Initialize audio context for visualization
                        initAudioContext(stream);
                    })
                    .catch(error => {
                        console.error('Error accessing microphone:', error);
                        updateStatus(`Error: ${error.message}`, true);
                        resetRecordingUI();
                    });
            } catch (error) {
                console.error('Error starting recording:', error);
                updateStatus(`Error: ${error.message}`, true);
                resetRecordingUI();
            }
        }

        async function handleRecordingComplete(blob) {
            try {
                // Process the recording to check for wake word
                const formData = new FormData();
                formData.append('audio', blob);
                formData.append('type', recordingType);
                formData.append('check_only', 'true');

                const response = await fetch('/api/process_sample', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error('Failed to process recording');
                }

                const data = await response.json();
                
                // Update status based on wake word detection
                if (data.metrics && data.metrics.wake_word) {
                    updateStatus('Wake word detected! Recording ready to save.');
                } else {
                    updateStatus('Wake word not detected. You may want to try recording again.', true);
                }

                // Show and enable play/save/discard buttons
                if (playButton) {
                    playButton.classList.remove('hidden');
                    playButton.disabled = false;
                }
                if (saveButton) {
                    saveButton.classList.remove('hidden');
                    saveButton.disabled = false;
                }
                if (discardButton) {
                    discardButton.classList.remove('hidden');
                    discardButton.disabled = false;
                }

                // Re-enable recording buttons
                if (recordHumanBtn) {
                    recordHumanBtn.classList.remove('hidden');
                    recordHumanBtn.disabled = false;
                }
                if (recordAIBtn) {
                    recordAIBtn.classList.remove('hidden');
                    recordAIBtn.disabled = false;
                }

                // Update metrics display if available
                if (data.metrics) {
                    updateMetricsDisplay(data.metrics);
                }
            } catch (error) {
                console.error('Error processing recording:', error);
                updateStatus(`Error: ${error.message}`, true);
            }
        }

        function checkVolumeLevel(stream) {
            return new Promise((resolve, reject) => {
                const audioContext = new AudioContext();
                const source = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                let totalVolume = 0;
                let sampleCount = 0;
                let startTime = Date.now();
                
                function checkVolume() {
                    analyser.getByteFrequencyData(dataArray);
                    const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                    totalVolume += average;
                    sampleCount++;
                    
                    // Update volume display
                    const volumePercent = Math.min(100, Math.round((average / 255) * 100));
                    const volumeBar = document.getElementById('volumeBar');
                    const volumeText = document.getElementById('volumeText');
                    
                    if (volumeBar) {
                        volumeBar.style.width = `${volumePercent}%`;
                        volumeBar.className = `progress-bar ${volumePercent < 3 ? 'bg-danger' : 'bg-success'}`;
                    }
                    
                    if (volumeText) {
                        if (volumePercent < 3) {
                            volumeText.textContent = 'Speak louder!';
                        } else if (volumePercent < 5) {
                            volumeText.textContent = 'Good volume, keep going!';
                        } else {
                            volumeText.textContent = 'Perfect volume!';
                        }
                    }
                    
                    if (Date.now() - startTime >= 3000) { // Check for 3 seconds
                        const avgVolume = totalVolume / sampleCount;
                        const volumePercent = Math.min(100, Math.round((avgVolume / 255) * 100));
                        
                        if (volumePercent < 3) {
                            resolve({
                                success: false,
                                message: 'Microphone volume is too low. Please speak louder.'
                            });
                        } else {
                            resolve({
                                success: true,
                                message: 'Volume level is good!',
                                volume: volumePercent
                            });
                        }
                    } else {
                        requestAnimationFrame(checkVolume);
                    }
                }
                
                checkVolume();
            });
        }

        async function initAudioContext(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            
            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            visualizerCanvas = document.getElementById('audioVisualizer');
            canvasCtx = visualizerCanvas.getContext('2d');
            volumeBar = document.getElementById('volumeBar');
            volumeLabel = document.getElementById('volumeLabel');
            
            function draw() {
                animationId = requestAnimationFrame(draw);
                
                analyser.getByteFrequencyData(dataArray);
                
                // Calculate volume level using RMS
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const amplitude = (dataArray[i] - 128) / 128;
                    sum += amplitude * amplitude;
                }
                const rms = Math.sqrt(sum / bufferLength);
                const volume = Math.min(100, Math.round(rms * 200)); // Adjusted multiplier for better sensitivity
                
                // Update volume indicator
                volumeBar.style.width = `${volume}%`;
                volumeLabel.textContent = `Volume Level: ${volume}%`;
                
                // Update volume bar color based on level
                if (volume < 3) {
                    volumeBar.style.background = 'linear-gradient(90deg, #ff4444, #ff6b6b)'; // Red for too low
                } else if (volume > 90) {
                    volumeBar.style.background = 'linear-gradient(90deg, #ff9900, #ffbb33)'; // Orange for too high
                } else {
                    volumeBar.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)'; // Green for good
                }
                
                // Draw waveform
                canvasCtx.fillStyle = '#f5f5f5';
                canvasCtx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                canvasCtx.lineWidth = 2;
                canvasCtx.strokeStyle = volume < 3 ? '#ff4444' : (volume > 90 ? '#ff9900' : '#4CAF50');
                canvasCtx.beginPath();
                
                const sliceWidth = visualizerCanvas.width / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * visualizerCanvas.height / 2;
                    
                    if (i === 0) {
                        canvasCtx.moveTo(x, y);
                    } else {
                        canvasCtx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                canvasCtx.lineTo(visualizerCanvas.width, visualizerCanvas.height / 2);
                canvasCtx.stroke();
                
                // Add volume threshold indicators
                const lowThresholdY = visualizerCanvas.height * 0.9; // 10% from bottom
                const highThresholdY = visualizerCanvas.height * 0.1; // 10% from top
                
                // Draw low threshold line
                canvasCtx.beginPath();
                canvasCtx.strokeStyle = '#ff4444';
                canvasCtx.setLineDash([5, 5]);
                canvasCtx.moveTo(0, lowThresholdY);
                canvasCtx.lineTo(visualizerCanvas.width, lowThresholdY);
                canvasCtx.stroke();
                
                // Draw high threshold line
                canvasCtx.beginPath();
                canvasCtx.strokeStyle = '#ff9900';
                canvasCtx.moveTo(0, highThresholdY);
                canvasCtx.lineTo(visualizerCanvas.width, highThresholdY);
                canvasCtx.stroke();
                
                canvasCtx.setLineDash([]);
            }
            
            draw();
        }

        function initializeWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                
                socket = new WebSocket(wsUrl);
                
                socket.onopen = () => {
                    console.log('WebSocket connection established');
                    updateStatus('Connected to server');
                    addLogEntry('WebSocket connection established', false, 'client', 'INFO');
                };
                
                socket.onclose = () => {
                    console.log('WebSocket connection closed');
                    updateStatus('Disconnected from server');
                    addLogEntry('WebSocket connection closed', false, 'client', 'INFO');
                    // Attempt to reconnect after 5 seconds
                    setTimeout(initializeWebSocket, 5000);
                };
                
                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('Connection error');
                    addLogEntry(`WebSocket error: ${error.message}`, true, 'client', 'ERROR');
                };
                
                socket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'log') {
                            addLogEntry(data.message, data.level === 'ERROR', data.source, data.level);
                        } else {
                            handleWebSocketMessage(data);
                        }
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                        addLogEntry(`Error parsing WebSocket message: ${error.message}`, true, 'client', 'ERROR');
                    }
                };
            } catch (error) {
                console.error('Error initializing WebSocket:', error);
                updateStatus('Failed to connect to server');
                addLogEntry(`Error initializing WebSocket: ${error.message}`, true, 'client', 'ERROR');
            }
        }

        function handleWebSocketMessage(data) {
            try {
                if (data.type === 'processing_complete') {
                    updateStatus(`Processing complete: ${data.message}`);
                } else if (data.type === 'error') {
                    updateStatus(`Error: ${data.message}`, true);
                }
            } catch (error) {
                console.error('Error handling WebSocket message:', error);
            }
        }

        function updateStatus(message, isError = false) {
            if (!statusElement) return;
            
            statusElement.textContent = message;
            statusElement.className = isError ? 'status error' : 'status';
        }

        function startBatchMode() {
            try {
                if (isRecording) {
                    updateStatus('Cannot start batch mode while recording', true);
                    return;
                }

                if (isBatchMode) {
                    // Stop batch mode
                    resetBatchMode();
                    return;
                }

                isBatchMode = true;
                batchCount = 0;
                updateStatus('Starting batch recording mode...');

                if (startBatchButton) {
                    startBatchButton.textContent = 'Stop Batch Mode';
                    startBatchButton.classList.add('danger');
                }

                if (batchStatus) {
                    batchStatus.textContent = 'Recording in batch mode';
                }

                // Start the first recording
                startNextBatchRecording();
            } catch (error) {
                console.error('Error starting batch mode:', error);
                updateStatus('Error starting batch mode', true);
                resetBatchMode();
            }
        }

        function startNextBatchRecording() {
            if (!isBatchMode) return;

            // Alternate between human and AI recordings
            const type = batchCount % 2 === 0 ? 'human' : 'ai';
            startRecording(type);

            // Update progress
            if (batchProgress && batchProgressBar) {
                batchProgress.textContent = `${batchCount}/10`;
                batchProgressBar.style.width = `${(batchCount / 10) * 100}%`;
            }
        }

        function handleBatchSuccess() {
            batchCount++;
            
            if (batchCount >= 10) {
                // Batch complete
                updateStatus('Batch recording complete!');
                resetBatchMode();
                return;
            }

            // Short delay before next recording
            setTimeout(() => {
                updateStatus('Starting next batch recording...');
                startNextBatchRecording();
            }, 1000);
        }

        function handleBatchError() {
            updateStatus('Error in batch recording', true);
            resetBatchMode();
        }

        function resetBatchMode() {
            isBatchMode = false;
            batchCount = 0;

            if (startBatchButton) {
                startBatchButton.textContent = 'Start Batch Recording';
                startBatchButton.classList.remove('danger');
            }

            if (batchStatus) {
                batchStatus.textContent = 'Ready for batch recording';
            }

            if (batchProgress && batchProgressBar) {
                batchProgress.textContent = '0/10';
                batchProgressBar.style.width = '0%';
            }

            resetSampleUI();
        }

        async function saveSample() {
            try {
                if (audioChunks.length === 0) {
                    throw new Error('No audio recorded');
                }

                const blob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });
                const formData = new FormData();
                formData.append('audio', blob);
                formData.append('type', recordingType);
                formData.append('timestamp', new Date().toISOString());

                // First check if wake word is detected
                const checkResponse = await fetch('/api/process_sample', {
                    method: 'POST',
                    body: formData
                });

                if (!checkResponse.ok) {
                    const errorData = await checkResponse.json();
                    throw new Error(errorData.error || `HTTP error! status: ${checkResponse.status}`);
                }

                const checkData = await checkResponse.json();
                
                // If wake word is not detected, show warning but allow saving
                if (!checkData.metrics?.wake_word) {
                    const shouldSave = confirm('Warning: Wake word not detected. Do you want to save this sample anyway?');
                    if (!shouldSave) {
                        updateStatus('Sample not saved - wake word not detected');
                        addLogEntry('Sample not saved - wake word not detected', false, 'client', 'WARNING');
                        return;
                    }
                }

                // Proceed with saving
                const saveResponse = await fetch('/api/process_sample', {
                    method: 'POST',
                    body: formData
                });

                if (!saveResponse.ok) {
                    const errorData = await saveResponse.json();
                    throw new Error(errorData.error || `HTTP error! status: ${saveResponse.status}`);
                }

                const data = await saveResponse.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to save sample');
                }

                // Only disable buttons after successful save
                if (playButton) playButton.classList.add('hidden');
                if (saveButton) {
                    saveButton.classList.add('hidden');
                    saveButton.disabled = true;
                }
                if (discardButton) {
                    discardButton.classList.add('hidden');
                    discardButton.disabled = true;
                }

                // Update metrics display if available
                if (data.metrics) {
                    updateMetricsDisplay(data.metrics);
                }

                updateStatus('Sample saved successfully');
                addLogEntry('Sample saved successfully', false, 'client', 'INFO');

                // Update progress counters
                if (recordingType === 'human') {
                    humanSamplesCount++;
                    if (humanProgress && humanProgressBar) {
                        humanProgress.textContent = `${humanSamplesCount}/5`;
                        humanProgressBar.style.width = `${(humanSamplesCount / 5) * 100}%`;
                    }
                } else {
                    aiSamplesCount++;
                    if (aiProgress && aiProgressBar) {
                        aiProgress.textContent = `${aiSamplesCount}/5`;
                        aiProgressBar.style.width = `${(aiSamplesCount / 5) * 100}%`;
                    }
                }

                // Reset audio state
                audioChunks = [];
                currentAudio = null;

                // Immediately reload the samples list
                await loadSavedSamples();

                // Handle batch mode success
                if (isBatchMode) {
                    handleBatchSuccess();
                }

                return data;
                
            } catch (error) {
                console.error('Error saving sample:', error);
                updateStatus(`Error: ${error.message}`, true);
                addLogEntry(`Error saving sample: ${error.message}`, true, 'client', 'ERROR');
                
                // Keep buttons enabled if save fails
                if (saveButton) saveButton.disabled = false;
                if (discardButton) discardButton.disabled = false;
                
                if (isBatchMode) {
                    handleBatchError();
                }
                throw error;
            }
        }

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            });
        }

        async function loadSavedSamples() {
            try {
                const response = await fetch('/api/list_samples');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                const samples = data.samples || [];
                
                const samplesList = document.getElementById('samplesList');
                if (!samplesList) {
                    throw new Error('Samples list element not found');
                }
                
                // Clear existing samples
                samplesList.innerHTML = '';
                
                if (samples.length === 0) {
                    samplesList.innerHTML = '<div class="no-samples">No samples recorded yet</div>';
                    return;
                }
                
                // Sort samples by timestamp, newest first
                samples.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                samples.forEach(sample => {
                    const sampleDiv = document.createElement('div');
                    sampleDiv.className = 'sample-item';
                    sampleDiv.innerHTML = `
                        <div class="sample-header">
                            <span class="sample-type ${sample.type.toLowerCase()}">${sample.type}</span>
                            <span class="sample-timestamp">${formatTimestamp(sample.timestamp)}</span>
                        </div>
                        <div class="sample-metrics">
                            <div class="metric">Volume: ${sample.metrics?.volume_level || 0}%</div>
                            <div class="metric">SNR: ${sample.metrics?.signal_to_noise || 0}dB</div>
                            <div class="metric">Clarity: ${sample.metrics?.clarity || 0}%</div>
                        </div>
                        <div class="sample-controls">
                            <button class="play-button" onclick="playSample('${sample.filename}')">Play</button>
                            <button class="delete-button" onclick="deleteSample('${sample.filename}')">Delete</button>
                        </div>
                    `;
                    samplesList.appendChild(sampleDiv);
                });
                
                // Update counts
                humanSamplesCount = samples.filter(s => s.type.toLowerCase() === 'human').length;
                aiSamplesCount = samples.filter(s => s.type.toLowerCase() === 'ai').length;
                
                // Update progress bars
                if (humanProgress && humanProgressBar) {
                    humanProgress.textContent = `${humanSamplesCount}/5`;
                    humanProgressBar.style.width = `${(humanSamplesCount / 5) * 100}%`;
                }
                if (aiProgress && aiProgressBar) {
                    aiProgress.textContent = `${aiSamplesCount}/5`;
                    aiProgressBar.style.width = `${(aiSamplesCount / 5) * 100}%`;
                }
                
            } catch (error) {
                console.error('Error loading samples:', error);
                updateStatus('Error loading samples', true);
            }
        }

        async function deleteSample(filename) {
            try {
                const response = await fetch(`/api/delete_sample/${filename}`, {
                    method: 'DELETE'
                });

                if (!response.ok) throw new Error('Failed to delete sample');

                // Remove the sample from the UI
                const sampleItem = document.querySelector(`.sample-item[data-filename="${filename}"]`);
                if (sampleItem) {
                    sampleItem.remove();
                }

                // Update progress if needed
                if (recordingType.toLowerCase() === 'human') {
                    humanSamplesCount = Math.max(0, humanSamplesCount - 1);
                    humanProgress.textContent = `${humanSamplesCount}/5`;
                    humanProgressBar.style.width = `${(humanSamplesCount / 5) * 100}%`;
                } else {
                    aiSamplesCount = Math.max(0, aiSamplesCount - 1);
                    aiProgress.textContent = `${aiSamplesCount}/5`;
                    aiProgressBar.style.width = `${(aiSamplesCount / 5) * 100}%`;
                }
            } catch (error) {
                console.error('Error deleting sample:', error);
                updateStatus('Error deleting sample', true);
            }
        }

        function resetSampleUI() {
            if (recordHumanBtn) {
                recordHumanBtn.textContent = 'Start Human Recording';
                recordHumanBtn.classList.remove('danger', 'hidden');
                recordHumanBtn.disabled = false;
            }
            if (recordAIBtn) {
                recordAIBtn.textContent = 'Start AI Recording';
                recordAIBtn.classList.remove('danger', 'hidden');
                recordAIBtn.disabled = false;
            }
            if (playButton) {
                playButton.classList.add('hidden');
                playButton.disabled = true;
            }
            if (saveButton) {
                saveButton.classList.add('hidden');
                saveButton.disabled = true;
            }
            if (discardButton) {
                discardButton.classList.add('hidden');
                discardButton.disabled = true;
            }
            
            currentAudio = null;
            audioChunks = [];
            
            if (statusElement) {
                statusElement.textContent = 'Ready to record';
            }
        }

        function resetRecordingUI() {
            // Reset recording buttons
            if (stopRecordingBtn) {
                stopRecordingBtn.classList.add('hidden');
                stopRecordingBtn.disabled = true;
            }
            if (recordHumanBtn) {
                recordHumanBtn.classList.remove('hidden');
                recordHumanBtn.disabled = false;
            }
            if (recordAIBtn) {
                recordAIBtn.classList.remove('hidden');
                recordAIBtn.disabled = false;
            }
            
            // Reset playback controls
            if (playButton) {
                playButton.classList.add('hidden');
                playButton.disabled = true;
            }
            if (saveButton) {
                saveButton.classList.add('hidden');
                saveButton.disabled = true;
            }
            if (discardButton) {
                discardButton.classList.add('hidden');
                discardButton.disabled = true;
            }

            // Reset status
            if (statusElement) {
                statusElement.textContent = 'Ready to record';
            }

            // Reset audio state
            audioChunks = [];
            currentAudio = null;
        }

        function discardRecording() {
            try {
                // Clean up audio resources
                if (audioContext) {
                    cancelAnimationFrame(animationId);
                    audioContext.close();
                    audioContext = null;
                }

                // Reset audio state
                audioChunks = [];
                currentAudio = null;

                // Reset UI
                resetRecordingUI();

                // Update status
                updateStatus('Recording discarded');
                addLogEntry('Recording discarded', false, 'client', 'INFO');

            } catch (error) {
                console.error('Error discarding recording:', error);
                updateStatus(`Error discarding recording: ${error.message}`, true);
                addLogEntry(`Error discarding recording: ${error.message}`, true, 'client', 'ERROR');
                
                // Even if there's an error, try to reset the UI
                resetRecordingUI();
            }
        }

        function updateMetricsDisplay(metrics) {
            try {
                // Update volume level
                const volumeLevel = document.getElementById('volumeLevel');
                if (volumeLevel) {
                    volumeLevel.textContent = `${metrics.volume_level}%`;
                    volumeLevel.className = `quality-metric ${getQualityClass(metrics.volume_level, 'volume')}`;
                }

                // Update noise level (SNR)
                const noiseLevel = document.getElementById('noiseLevel');
                if (noiseLevel) {
                    noiseLevel.textContent = `${metrics.signal_to_noise}dB`;
                    noiseLevel.className = `quality-metric ${getQualityClass(metrics.signal_to_noise, 'noise')}`;
                }

                // Update clarity level
                const clarityLevel = document.getElementById('clarityLevel');
                if (clarityLevel) {
                    clarityLevel.textContent = `${metrics.clarity}%`;
                    clarityLevel.className = `quality-metric ${getQualityClass(metrics.clarity, 'clarity')}`;
                }

                // Update duration check if available
                const durationCheck = document.getElementById('durationCheck');
                if (durationCheck && metrics.duration) {
                    durationCheck.textContent = `${metrics.duration.toFixed(1)}s`;
                    durationCheck.className = `quality-metric ${metrics.duration >= 0.5 && metrics.duration <= 15.0 ? 'good' : 'bad'}`;
                }

                // Update wake word detection status
                const wakeWordCheck = document.getElementById('wakeWordCheck');
                if (wakeWordCheck) {
                    wakeWordCheck.textContent = metrics.wake_word ? 'Detected' : 'Not Detected';
                    wakeWordCheck.className = `quality-metric ${metrics.wake_word ? 'good' : 'bad'}`;
                }

                // Update overall quality
                const overallQuality = document.getElementById('overallQuality');
                if (overallQuality) {
                    overallQuality.textContent = `${metrics.quality_score}%`;
                    overallQuality.className = `quality-metric ${getQualityClass(metrics.quality_score, 'overall')}`;
                }

                // Add clipping warning if needed
                if (metrics.clipping_percentage > 1) {
                    updateStatus(`Warning: ${metrics.clipping_percentage}% of audio is clipping`, true);
                }
            } catch (error) {
                console.error('Error updating metrics display:', error);
                addLogEntry(`Error updating metrics display: ${error.message}`, true, 'client', 'ERROR');
            }
        }

        function getQualityClass(value, type) {
            switch (type) {
                case 'volume':
                    if (value < 3) return 'bad';
                    if (value < 5) return 'warning';
                    if (value > 90) return 'warning';
                    return 'good';
                case 'noise':
                    if (value < 5) return 'bad';
                    if (value > 95) return 'warning';
                    return 'good';
                case 'clarity':
                    if (value < 50) return 'bad';
                    if (value < 70) return 'warning';
                    return 'good';
                case 'overall':
                    if (value < 60) return 'bad';
                    if (value < 80) return 'warning';
                    return 'good';
                default:
                    return value > 70 ? 'good' : value > 40 ? 'warning' : 'bad';
            }
        }

        // Update the handleAudioData function to display metrics
        async function handleAudioData(audioBlob, timestamp) {
            try {
                const formData = new FormData();
                formData.append('audio', audioBlob);
                formData.append('timestamp', timestamp);
                formData.append('type', 'recording');
                
                const response = await fetch('/save-sample', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                if (result.success) {
                    showMessage('Sample saved successfully', 'success');
                    updateMetricsDisplay(result.metrics);
                } else {
                    showMessage(result.error || 'Failed to save sample', 'error');
                }
            } catch (error) {
                console.error('Error saving sample:', error);
                showMessage('Error saving sample', 'error');
            }
        }

        // Add this function to handle collapsible sections
        function toggleCollapsible(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.toggle-icon');
            
            if (content.classList.contains('show')) {
                content.classList.remove('show');
                icon.textContent = '▼';
            } else {
                content.classList.add('show');
                icon.textContent = '▲';
            }
        }

        function playRecording() {
            try {
                if (!currentAudio) {
                    throw new Error('No audio available to play');
                }

                const avatar = document.getElementById('avatar');
                if (avatar) {
                    avatar.classList.add('listening');
                }

                // Create a new audio element
                const audio = new Audio(URL.createObjectURL(currentAudio));
                
                audio.onended = () => {
                    if (avatar) {
                        avatar.classList.remove('listening');
                    }
                };

                audio.onerror = (error) => {
                    console.error('Error playing audio:', error);
                    updateStatus('Error playing audio', true);
                    if (avatar) {
                        avatar.classList.remove('listening');
                    }
                };

                // Play the audio
                audio.play().catch(error => {
                    console.error('Error playing audio:', error);
                    updateStatus('Error playing audio', true);
                    if (avatar) {
                        avatar.classList.remove('listening');
                    }
                });
            } catch (error) {
                console.error('Error in playRecording:', error);
                updateStatus(`Error: ${error.message}`, true);
                const avatar = document.getElementById('avatar');
                if (avatar) {
                    avatar.classList.remove('listening');
                }
            }
        }

        async function playSample(filename) {
            try {
                const response = await fetch(`/api/get_sample/${filename}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch sample');
                }
                
                const blob = await response.blob();
                const audio = new Audio(URL.createObjectURL(blob));
                
                // Add event listeners for better feedback
                audio.onplay = () => {
                    addLogEntry(`Playing sample: ${filename}`, false, 'client', 'INFO');
                    const playButton = document.querySelector(`button[onclick="playSample('${filename}')"]`);
                    if (playButton) playButton.textContent = 'Playing...';
                };
                
                audio.onended = () => {
                    const playButton = document.querySelector(`button[onclick="playSample('${filename}')"]`);
                    if (playButton) playButton.textContent = 'Play';
                };
                
                audio.onerror = (e) => {
                    console.error('Error playing audio:', e);
                    addLogEntry(`Error playing sample: ${filename}`, true, 'client', 'ERROR');
                    const playButton = document.querySelector(`button[onclick="playSample('${filename}')"]`);
                    if (playButton) playButton.textContent = 'Play';
                };
                
                await audio.play();
            } catch (error) {
                console.error('Error playing sample:', error);
                addLogEntry(`Error playing sample: ${error.message}`, true, 'client', 'ERROR');
                updateStatus('Error playing sample', true);
            }
        }

        function addLogEntry(message, isError = false, source = 'client', level = 'INFO') {
            const logsList = document.getElementById('logsList');
            if (!logsList) return;

            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${isError ? 'error' : ''} ${level.toLowerCase()}`;
            
            const timestamp = new Date().toLocaleTimeString();
            logEntry.innerHTML = `
                <span class="log-time">[${timestamp}]</span>
                <span class="log-source">[${source}]</span>
                <span class="log-level">[${level}]</span>
                <span class="log-message">${message}</span>
            `;
            
            logsList.insertBefore(logEntry, logsList.firstChild);
            
            // Keep only the last 100 log entries
            while (logsList.children.length > 100) {
                logsList.removeChild(logsList.lastChild);
            }
        }
    </script>
</body>
</html> 



